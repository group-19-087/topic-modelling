All right, in our first module you were
introduced to the project that you're going to be doing throughout this course. And we hope that you think
it's as exciting as we do, visualizing this geospatial data. In this module though, we're going to
be stepping a little bit away, and we're going to be talking
about some of the concepts that underly the code that
you're going to be writing. So, by the end of this module, you're going to be able to motivate the
use of classes and objects in programming. So, why do we want to use classes and
objects when we write our programs? You'll be able to write classes in Java,
and then create instances, or objects of those classes. And you'll be able to describe
the parts of a class, like member variables,
methods, and constructors. So in order to motivate the use of
classes and objects in programming, I want to go back to my favorite
definition of computer science. And of course, software engineering and
software development, which is what we're
focusing on this course and this specialization,
is a major part of computer science. So my favorite definition
of computer science is, that computer science is the science of
using and processing large amounts of information to automate useful tasks and
learn about the world around us. Of course, all using a computer,
because none of this would be possible if we didn't have the computational
power that the computer affords us. I'm gonna zero in on this
line in the definition, this idea of using large
amounts of information. These programs that you're going to be
writing and programs that people write, if you think about programs out in the world,
deal with huge amounts of information, so much information it's almost
impossible to get your mind around it. So one of the fundamental
questions in writing programs is, how do we organize this information? How do we organize it in a way such
that our programs are easy to write, easy to maintain, and easy to debug? Well the philosophy behind object oriented
program, object oriented programming, is to build our programs in a way that match
the problem that we're trying to solve. So if we go back to our project and the problem we're trying to solve, it's
to visualize geospatial data on a map. And if we think about what's
involved in solving that problem, we can think of lots of
real-world objects and entities that are part of this
problem that we're solving. So we can think of things
like the map itself. That's an object that
we're all familiar with. Shapes. Shapes are objects that have properties. We could talk about the shapes of
the countries, for example, in this map. Locations in the map,
colors of the objects in the map, even the window in which
the map is displayed. Plenty more objects as well, but these are all ideas that have
real world counterparts. And the idea behind writing
an object-oriented program to solve this problem, is that we're going to structure
our code around these real-world concepts. So in order to build our code in this way
that matches the real world, we're gonna design these things called classes, and
what classes are, are just custom data types that we get to define to match
the problem that we're trying to solve. Now of course you're
familiar with classes, cuz you've been working with Java for
some time now. But we're gonna talk about really
the details of creating and using classes. So a class is a new kind of data that
we the programmer get to define. And it's kind of like a factory. It can produce pieces of data with
a template that we get to define. So I'm gonna use this factory icon
when I talk about class definitions. On the other hand, an object is the thing
that comes out of this factory. It's a piece of this data with this
custom type that we've defined. And some associated functionality
that goes along with that data. And I'll represent the objects with this
little symbol here to represent the things that are coming out of the factory as
we create objects using our classes. So you can think of this like
a real-world factory, right? Like a car factory. A car factory knows how to produce,
say, one kind of car. And it can produce many
of that kind of car. And once the cars are out in
the real world, well, at first, they all kind of look the same, but then each individual car can be
customized and it can be changed in its own way without affecting all the
other cars that came out of the factory. The same thing's going to happen for
our classes and our objects in our Java programs. So we're gonna go through
an example of creating a class. And the class we're gonna
create has to do with this map example that we've been working with. So here's a map of the world. I'm gonna zoom in on one
particular place in the world, which is where this orange box is, which is approximately where I'm standing
right now on the campus of UC San Diego. So here's the University of California, San Diego campus, and
I'm about right here on this map. So what I want to do is,
I want to build a class that can represent my location in the world, or can
represent anyone's location in the world. So the question I have to ask myself is, what do I need to know in
order to represent a location? Well for this example, I'm going to
represent the concept of a location using two pieces of data, the latitude and
the longitude of this location. And in my case, for
this location right here, you can see these approximately my
latitude and longitude coordinates. So let's define a class that
represents this notion of a location. Here's my class definition. So I'm telling Java that I want
a new class called SimpleLocation. And you can see that on the top
line in this declaration. I say, public class SimpleLocation. SimpleLocation is the name of the class. The keyword class tells Java
that I'm creating a new class. And public, which we'll talk about
more in some of the next videos. Just means that my class
is public to the world. Anyone can use it. Inside, after that first curly brace,
is the definition of my class. Now before we look closely at
the definition, I wanna point out that all of this code has to exist in
a file called SimpleLocation.java. That's just a rule that Java enforces. That when you're creating a class, you
have to put it in a file that has the same name as the class, and that's if
the class is public, which our class is. So all this code is in a file
called SimpleLocation.java. So let's look a little closely at
the definition for this class. Up here you can see the data that I
have associated with my simple location. I had a latitude and a longitude. And I'll represent both of these
using double type variables. These are what are called
member variables. These are variables that exist throughout
the class that represent some essential pieces of data that I need to represent
my simple location in this case. And notice that they're declared
outside of any methods, but inside the declaration of the class. So, they come after that
open curly brace for the class, but
not inside any particular method. My class also has some
methods associated with it. So it has, for example, that method
that you see down there at the bottom. The distance method, and
what the distance method does is, it takes some other simple location out in
the world as a parameter, and it returns the distance between on simple location
and the simple location that's passed in. So that's something that my class can do. So these are the methods. These are the things that my class can do. And I want to zero in now on this
special method called the constructor. So this is the constructor, and this is a special method that gets
called when my objects get created. So when I ask Java to give me a new
object of type SimpleLocation, it's going to call this method here,
which is called the constructor. And the reason you know
it's the constructor, is that it doesn't have a return type,
so it simply says public and then next word in the declaration of this
method is just the name of the class. So public, SimpleLocation,
that's my constructor. This constructor happens
to take two arguments. And it takes the values of those
arguments that are passed in and stores them away in those member
variables, latitude and longitude. Now you might see this key word, this. This dot latitude. This dot longitude. You might be wondering what is is. We're gonna talk about that
in just a couple of minutes. So all of this together is my
class declaration, SimpleLocation. Class has two member variables and
couple of methods. And again,
it's in the file SimpleLocation.java. So now, how do I use this class? Let's take a look at some
code that actually creates objects of type simple locations and
does something with them. So now I'm gonna go over into
a totally different file. I'm gonna go into a file
called LocationTester.java. Inside a totally different class, because
everything in Java has to be in a class, and I'm gonna look at a main
method inside that class. This main method is fairly simple. It just has three lines of code. And the first two lines
of code are creating new objects of this type SimpleLocation,
the class that I just wrote. So, you can see here that I declare
two new variables, ucsd and lima. And I'm creating two new
SimpleLocation objects to represent the location of where
I'm standing here at UC San Diego. And then the location of Lima, Peru. When I call new, and
then say SimpleLocation, and then have the parentheses
in passing those arguments. What that's doing is, that's going over
into the SimpleLocation class definition and calling the constructor. So those arguments you saw being passed
in, those are gonna go in as arguments. To this constructor, which is going to store those values away
inside the object that just got created. So I call the constructor twice,
I get two new objects. Then I can use those objects in
some code like I do down here. So, what I'm doing here is,
I'm taking my ucsd SimpleLocation object. And I'm calling the distance method on it, passing it in the SimpleLocation object
that represents the location of Lima. So let's take a look at how that works. When I call that method, it's going to invoke this method distance
that's inside the class SimpleLocation. All right.
So let's look in a little bit more
detail what's going on here, so we can understand the difference
between UCSD and Lima. So when I call ucsd.distance and pass in the parameter lima, like I
mentioned before, it invokes that method called distance inside the SimpleLocation
class, which you can see right here. Now I'm showing you just a little bit of
what the body of that method might look like, so
that I can illustrate a couple of points. We're comparing the distance
between two SimpleLocation objects. One of those objects, lima, is past in
as an argument to the function, and that's gonna be stored in the parameter,
other. So I can see that other is used
inside the body of the method when I get its latitude and its longitude. But what happened to ucsd? How are we getting the latitude and
longitude of ucsd? That's where the keyword, this, comes in. This refers to the calling object, which
is the object that called the method, or on which the method was called. So in this line of code, ucsd dot
distance and then pass in lima UCSD is called the calling object because it's
the object that occurs before that dot. So when I'm inside this method,
this will refer to the location of UCSD. So that way I can get the latitude and
longitude of where I'm standing here at UCSD, and compare it to
the latitude and longitude of Lima, Peru. and return the distance. Putting it all together,
when I run this code by compiling it and running it, I see that distance between
where I'm standing now, and Lima, Peru, is approximately 6,568 kilometers. So those are some objects basics. In the next couple videos, we'll introduce
you to some more subtle details and interesting things you can do when
creating classes and objects.Okay, now that you know the basics
of creating classes and objects in Java, let's talk about
overloading methods which is another thing that you're going to do and work with a
lot as you work with classes and objects. So by the end of this video you'll be
able to give examples of what overloading methods is in Java. You'll be able to explain how to overload
methods, and how not to overload methods in Java, and you'll be able to explain
why it's useful and why we wanna do it. Let's go back to our simple location
class that we worked with last video. So we saw this class, here it is,
it has a couple of member variables. It has a constructor, and
it has a method called, distance. Of course, you know by now that it must
be in a file called, SimpleLocation.java. Now let's say right now we have one
constrictor, it allows the user to create objects of type simple location
by passing in a latitude and longitude. But let's say that the user doesn't want
to always have to pass in a latitude and longitude and, they want to be
able to create SimpleLocation objects without passing in any parameters. Right now,
the user of our class can't do that because there's no constructor
defined that takes no parameters. But we can fix that. We can create a new constructor
that takes no parameters, and create still a new simple location object. Now, you might wonder, well where
should this simple location object be if the user doesn't
give us any parameters. And since I'm here at UC San Diego, I'm gonna create my class that will always
create simple location objects here at my location at UC San Diego unless the user
tells me to create it somewhere else. So what I've done is I've added a new
constructor that takes no arguments which, by the way,
is called the default constructor. It's just the constructor that you can
invoke without passing in any data at all. And it will give my parameters, a sorry, it will give my number variables,
latitude and longitude, these default values, which is the
location of where I'm standing right now. I still have my other constructor,
which takes the two arguments, latitude and longitude, lat and lon, and those two constructors can exist
happily together in the same class. This is exactly what I'm talking about
when I talk about overloading methods. So I've now created a class where
my constructor has been overloaded. There are two different copies of the
constructor that take different numbers and types of arguments. They both do the same thing more or less
in that they both create a new object, but how they assign values to latitude and
longitude differ slightly. So I can not only overload constructors, I
can also overload the methods in my class. So before I had one method
called distance, and it took in as a parameter
another SimpleLocation object. And, that was fine, but maybe I don't want
to force the user of my class to have to create a whole SimpleLocation object just
to find the distance to another location. So, I can overload the distance method
by creating another version of it that takes in two parameters other lat and
other lon. So instead of having to create a whole new
SimpleLocation object just to pass it into the distance function, the user of my
class can now call my distance method by passing in two parameters,
representing the latitude and longitude of the place that they're
trying to find the distance to. So two examples of overloading. Why do we care about overloading? Why is this useful? Let's take a look at how you're gonna
use it extensively in your project. So this is a little snippet of code that
we looked at back in module one that uses this UnfoldingMaps library to create
a new map and display it to the user. And what it does is it creates
a window of size 800 by 600 and then puts a new map inside that window. And when I run it I see
something like this. I've also created, I've added a line
of code that zooms in on San Diego so you see San Diego rather
than the whole world. So that's what I see when I run this code. But what if I decide that I don't
really like the fact that the map takes up the whole window, I'd like
to shrink the map down slightly so there's a nice border
around the edge of the map. I can do that. And I can do that by invoking a different
version of the UnfoldingMaps constructor. So this is an overloaded version
of the UnfoldingMap constructor that takes four additional parameters. So my original call to UnfoldingMap
just took two parameters. Now I'm calling the, the UnfoldingMap constructor
that takes six parameters total. And these four additional parameters
I've added specify the x and y position of where the map should appear
in the window, as well as the width and height of the map. So when I run this code, what I see
is a window that has a nice border around the map that it displays, because
the map is smaller than the window size. So this is pretty useful, but
you might wonder, well how do I even know? How do I know what constructors
are available to me? That's where the Java
documentation comes in. So you can go to the UnfoldingMap Java doc
just like we showed you in module one and you'll see all the constructors
detailed there. So here's the first constructor we
called that took two parameters and you can see what it does and
what those parameters are. And here's that second constructor that we
called that took those six parameters and you can see that the second
parameter's the x position of the map, the third parameter's the y position
of the map, and so on and so forth. And if you do go to
the unfolding map documentation, which I encourage you to do right now,
you'll see that there are actually like eight or nine different overloaded
constructors for UnfoldingMap. So you can create unfolding map objects
by passing it a wide variety of information and each of those constructors
will do something slightly different. So before we end this video,
I want to caution you against something that seems really useful
but is actually not possible in Java. So you might think that it's a good
idea to overload the distance method instead of by changing the parameter list,
by changing the return type. So let's say you want a distance method
that returns a double type, but you also want a distance method that's slightly
less precise and returns an integer type. So you say, oh,
I'll just overload the distance method and make the other one return an integer. Unfortunately that is not allowed,
you can't do that, java will complain. You have to have some difference in the
parameter list when you overload a method. You're not allowed to have
a method with the same name, and the same parameter list,
and a different return type. And the reason for that is a little bit
beyond the scope of this course, but it has to do with how the compiler works. At compile time, Java C,
the compiler, has to decide which version of the overloaded method
you're actually trying to call. And it does that by using
the parameter list. It can't do that by using
the return type alone. So Java doesn't let you do
this type of overloading. So that's all for overloading and
in the next video, we'll talk about a few more
details of objects and classes.In the last video,
we saw how objects are constructed from
the inside out in Java. And the way this happens is
really through compiler rules. We're gonna talk about what those compiler
rules are and how those compiler rules work, in order to ensure, again, that
the object is created from the inside out. Where we left off in the last
video is we'd seen the process, we'd seen how student calls
person which calls object. And those constructors return back and in the process of returning back they
actually initialize the variables. But you've said at the end but wait,
I don't remember extending object. Where did we do this? This introduces our first rule
associated with a compiler. So let's revisit where the compiler
plays a role in our process. You write code, human-readable Java code, and that gets sent off
to the Java compiler. The Java compiler's going
to do a number of passes. In fact, there's a number of potential
specializations you could write instead of just on how the compiler works. What we're going to focus in on
is essentially a couple of passes the compiler does as
terms of inserting code. When the compiler is all said and
done we know it produces the Bytecode which we then
run our java virtual machine. So what is a Java compiler doing and
what are these rules? What it does is its going
to change the code. So, if you wrote this class, public
class Person, and you just have your single instance variable, and
I've done away with any other code, it's just this class,
is this actually what gets compiled? In a sense, no, cuz the compiler takes this code and
it's gonna change the code a bit. What it's gonna do is follow three rules
that we're gonna talk about in this video. First rule is,
if you don't have a superclass, the compiler's gonna give you one. It's gonna give you Object. So even though you wrote
public class Person, the compiler's gonna insert the terms,
extends Object. By doing this, now you see how
person inherits from object just because it inserts those
lines of code implicitly. But where then, do we call the person
constructor, or the object constructor? We know now that object inherits, or
sorry person inherits from objects, but we don't know where those
constructors are getting called? That's where the next set of rules come. So first off,
if you don't have a constructor, Java's gonna give one for you. It's gonna give you a default
constructor so no arguments. And then it's gonna apply
another set of rules which are associated
with all constructors. This set of rules or Rule #3 is
that the 1st line of a constructor has to say either this,
and then some arguments. So call another constructor
within the same class. Or it has to call one of
the parent class instructors, a super class constructor call. It has to do one of those things. And if you don't do it,
Java is gonna insert super. So it's gonna call, It's gonna insert a call to the default
constructor of your super class. So now we see that we've added this
line to the person constructor. In a sense you've the code on the left but
the compiler is gonna insert all those elements on blue on the right and
that's what's really gonna get compiled. So now we have an idea of
how this work for person. I want you to pause and think about
what would happen to the Student class On the first pass by that compiler. All right, if you were thinking
we should add a very similar constructor to student that we did to
person, you're on the right track. It already extends from person,
so we can't extend from object. It already has a super class so
there's no need to do that first rule. The second rule applies,
it has no constructor so we have to insert a default constructor. And then the third rule applies of I
have to make sure I call the default constructor of my super class as the very
first line of my default constructor here. So you're gonna take that
code in black above and it's gonna get transformed
into the code in blue below. So when we were curious how is
the compiler making sure that this construction and the initialization
of our variables happens essentially from the highest level of
the hierarchy all the way back down. So it is the compiler makes it happen. Now there's still one leftover problem and
that is, we haven't actually initialized anything. Right all of our default constructors
have done no initialization. They've just made sure they go
all over the up to object and all the way back down. We had at least one variable and that was
name, the instance variable with Person. In our next video we're gonna
see how to initialize that.In the past couple of videos, we've been
starting to look at how class creation, or object creation happens in Java, specifically how does inheritance
apply to object creation. In the last video, we actually looked
at a number of compiler rules. Now these compiler rules are what the
compiler does when it looks at your code. Now the reason we want to
know about these rules, is because it's going to
help us trace our code. In fact, we're going to see an error
in our code here in just a little bit, which comes about because of these rules. We're also going to use
same-class constructors, and super class constructors to
help with class creation. Now we started by saying all objects
are created from the inside out. In the last video we saw how
the compiler rules make this happen. But what we did with the last video was
essentially just create a number of default constructors without
actually initializing anything. So what we're gonna do now is modify
these to initialize the name variable. Again, you've likely initialized
a variable before in a constructor. What we're focusing on are the elements
that apply to inheritance. So let's start off with our person class. Remember that the extends object was
automatically put there by the compiler. And what we're gonna do instead of
having it automatically put there, is we're gonna explicitly put it here. Likewise, I'm gonna explicitly
put the default constructor which would have been inserted
by the compiler anyway. And what we're gonna so now is modify this default constructor
to initialize the name variable. So let's add a string
argument to the constructor. Let's add this.name = n and
just do what we would of done before. Now, to be honest if we didn't have
that call to super we'd be fine. But because I've now inserted this line,
I've got an error. Remember that rule. The very first line of instructor has to
be a call to your same class constructor or a super class constructor. I have broken this rule
by saying this.name = n. And because I have a call
to super() after that, this is going to produce
a fairly cryptic compiler error. Now you know what that error means and you
can fix it by just switching the order. So now i'm calling my superclass
constructor correctly and now I can initialize my variable. Let's modify the student class now to
initialize the variables there as well. So i'm gonna take default
student constructor and i'm gonna make changes to it. I'm gonna insert String n. I'm gonna insert as a parameter, and I'm
also going to initialize that variable. Is this gonna work? I want you to pause and
think about this for a few seconds. Look at the code and
see if there's any errors here. If you start to recognize that I'm not
allowed to say this.name, you're right. That's a private variable
in the person class. I'm not allowed to direct the access
of that in the student class, I'd have to use a getter or
a setter to do so. But I don't have a getter or a setter. Is there a way for me to do this? Can I initialize name without
having the public getter setter? The answer is yes. All I have to do is change this now
to call the superclass constructor that takes an argument,
which is gonna initialize to be named. Perfect. So, just cross out those two lines, replace it with super,
with that name variable being passed in. And it's gonna initialize
everything properly. Let's go a little bit further with this,
though. Let me add one more constructor
to that student class. Let me add in, so this is our code
from where we just left off, and now let me add in that
no-arg default constructor. Now you should might be tempted to do
with a no-arg default constructor and let's just throw in some
kind of default name here. Is to just say super student. This will work, it's not the word idea but
is there a better way to do this? Yes, there is. There is no reason I should be
calling these super classes. Argument constructor when I
have one in my own class. A better way to do this
would be to do it like this. I should use my own same class
constructor if it's available to me, because they maybe code within
my same class constructor which does things that I wanna
initialize based on this. I shouldn't just jump
straight to the super class. But having done all these pieces, we now
see how object creation happens in Java. We see that it happens
from the inside out, we see that everything inherits
from object, and we now know how to use Superclass Constructors and Ownclass
constructors design our classes better.All right in Leo's videos you learned how
objects are created from the inside out. So in this concept challenge you're
going to be tracing through some code that calls some constructors. And the goal is to figure out what gets
printed as these constructors run. So you know the drill. You've done these before. What you're gonna need
to do is you're going to go be somewhere where you can spend
a little time on this and pause the video. Answer the quiz by yourself first. And then find some friends. Find some people you're taking
the class with ether in person or on the online forums. Try to discuss this question. See if you all agree. And then watch our learner video. And finally watch our explanation. So if you're ready to go
here's the challenge. You can see over here that
we've got two classes. There's a person class and
a student class. And those classes have
a number of constructors. The person class has a single constructor. It takes one argument, a string. And the student class has
two different constructors. A no argument constructor and then public
constructor that takes one argument. So what we're gonna do is we're gonna make
a single call to the Student constructor to the default constructor right up here. And it's gonna create a Student object. And the question for you is what
gets printed when we make that call? So go ahead and pause the video and
take the online quiz that's coming up. I'm Linda. >> I'm Mustafa. >> Hello, I'm Jason. >> Okay, so for this first question,
I was a little unclear on the answer. My instinct was to go for E for
lets just say #2, because the new student is the the no-argument constructor in
the student class, it just prints out #2. >> I'm not,
I was really confused about this too. >> My first system was like,
probably three, two, one. Because when you have a class and it goes through constructor it goes
from inner one into most other one. >> Right. >> But
then I look at it more carefully and I realized
>> When you go to students there's a super implicitly inserted. >> I was confused cuz the no
argument constructor, the first cold and the other this
constructor with the student. So I didn't know if it went
first to the super class or to the other constructor
within the one class. >> Cuz it would construct within the one
class called super, as well, so. >> All right, so now that you've had an opportunity to
work through this problem yourself and hopefully discuss it with some people,
let me go through our explanation. So what we're doing is creating
a Student object right up here, Student s = new Student. And you can see that we're
calling the default constructor. So we're gonna jump right over here to the
defunct constructor for the Student class. So public Student,
no argument constructor. But if you look at the first
line of this constructor, you can see what it immediately does is
it calls the one argument constructor for the Student class, which has one argument,
which is the string Student. So we're gonna jump down here to
the one argument constructor and start executing there. We start executing there but again,
the first line in that constructor says to call the constructor of
the super class which is Person. We pass in an argument, which is what
it requires qnd we go up here and start executing the constructor for
the person class. We haven't printed anything yet. We haven't really executed
any lines at all. We're just sort of getting ready
to call these constructors. So, we're gonna go over here. Get ready to call the one argument
constructor for the person class and the first thing that it says
is that it sets this.name. So, the name field in this object
we're creating equal to n, the string we pass in. That's fine, and then the next
line here is a print statement. So System.out.print("#1 "). This is the first print
statement we've encountered. So we're gonna print #1. That's the first thing that gets printed. So where does it go now? Well, we're finished
with this constructor. Here's the end of it. So we have to remember where we came from. Well where did we come from? Well we came from down here,
the one argument constructor for the student class. And we just finished calling the
constructor for the super class and we're now here on this line that says to print
out #3, so that's what we'll do next. Print number #3, so
that's the second thing that gets printed. Finally, this constructor ends. I will go back to where we came from,
which was the first constructor, the default constructor for
the student class. We just finished the call
to the one constructor. We're down here at this print statement
and we're going to print out the #2. And that's all there is to it. So this is what gets printed, #1, #2, #3.Okay, here's another concept challenge for
you, all about constructors, what happens when we call
the constructor of the Student class? We've got our familiar classes, here. We've got our Person class, and
we've got our Student class. And the constructors, check them out,
they're a little bit different. We've got a one argument constructor for
the Person class. A no argument constructor for
the Student class. And then this additional method
here in the Person class, which is setName, which will set
the name field inside the Person class. So, we're gonna ask you to
reason about what happens when you call the Student constructor. And, this is a concept challenge, so we want you to do the same procedure that
you're used to, just take that video quiz, first by yourself, then find some people
to chat about this question with, and then watch our learner video, and
come back and watch our explanation. >> Hi, I'm Alicia. >> Hi, I'm Joanna. >> Hello, I'm Justin. >> Okay, so what did you guys put? >> I think it's a compiled time error,
because Student doesn't have a name. So how can you set a name it doesn't have? >> Yeah, but I thought that
since Student extends Person, it actually inherits the name from Person. >> Oh.
>> So then, I actually put Student, because I thought that now it
goes into the constructive for Person and sets the name to Student. >> Yeah, I also thought the same. One thing I did notice was that Student calls Person, no argument constructor. And I noticed that there was no
argument constructed in Person, so I think that's the reason why
it causes the compile error. >> Yeah, okay, so yeah,
it's probably a compiled time error, then. >> Yeah.
>> All right, now that you've worked through this
yourself, let's work through it together. All we're doing here is we're calling
the Student default constructor. So let's trace the code and
see what happens. So we go over here to the Student
default constructor, and you might be tempted to just directly
go and execute this line that says this.setName to the string Student,
but the problem with that is, you'd be forgetting that the compiler actually
inserts some code into this constructor. If the first line of the constructor
is not either a call to the superclass constructor or a call to a constructor within the class,
the compiler is going to insert a line to the superclass constructor
that takes no arguments for us. So, in order to trace through this code,
we need to insert that line so we know exactly what's happening. So let's do that now. So now that we see this call to the
superclass constructor, we know that we have to go up to the Person class and
find the constructor with no arguments. So we go up to the Person class and we
look for a constructor with no arguments. I don't really see one, do you? It's not there, and it turns out
that Java will not insert one for us if we already had a constructor
that takes an argument. So this is gonna cause a compile error. So if you choose compile error,
you'd be correct. And the reason we're going
through this example is, it turns out it happens a lot that
you have a situation like this. I have it happen to me all the time and the compile error that you're
gonna get is very, very cryptic. You're gonna read it and be like,
what are you talking about, there is no constructor with no arguments? I didn't try to call
a constructor with no arguments. Well, you didn't. But, Java did, and
that's what's happening.Hi, and welcome back to our module
on Polymorphism Inheritance in Java. Today we'll be talking about method
overriding and you've already used method overriding when you did draw and
set up methods back when you designed your GUI but here we're gonna dive into
method overriding in a bit more detail. So goal here today is where the create
methods are override from superclass methods and will the contrast
overloading from method overriding. Back when we first started talking
about inheritance we had three goals. And overriding really
helps us has all three. So we wanna have common
code in one pairing class. We do this if we don't override a method. So if a method just exists in
the superclass we get back common code. But if we want our subclasses
to behave differently all we have to do is override a method and
now we get that different behavior. And because polymorphism which we'll
get to in the next set of videos we'll see that this allows us to have
all of our object in one structure and still be able to call
the appropriate method. It's really common for
new learners to mix up overloading and overriding so I want to talk just real
quickly about overloading and overriding. Overloading is the same class that has the
same method name but different parameters. So this is a different method signature,
within the same class. This is different then method overriding,
where you have a subclass that has same method signature, which means same name,
same parameters as a super class. So now let's start looking at some
more detail with a few examples. So first example is to look
at the object class itself. So we have a method in the outer
class called toString. And the odds are you probably already
ran toString method before, but if you haven't,
toString prints the contents or string representation of an object. Because it's in the object class,
all objects in Java can override it. So let's do this for our hierarchy. So we have our person class at the top,
It has a name and a getName and we're going to
add the toString method to it. To do so we're going to override the that
object method's toString method. Now, a really basic way to do this would
be to just return the name and since we already have right now in our person class
is name, this is really all we can do. And then in our code that calls it,
we're gonna create a Person p, we're gonna create a person that has the name Tim and
then we're gonna call this method. So you just do System.out.println and
put p.toString and that will return a string and
that is what we want. And it doesn't call
the object two string method, it's going to call the person two
string method because of override. Now it turns out that two string here
in this context is unnecessary because print line actually automatically
calls toString if you ever pass an object as a parameter to print line. So I'm gonna just display
it this way from here on. Now if we run this code, what's going to
happen is it's just going to print Tim. All right, well let's add to
our inheritance hierarchy. Now I'm gonna go to my student class
where we've already added a student ID. And I get student ID and now we're
going to add the method toString. Here's the code to essentially
have that student ID and the ability to get access to it. And now what I want, is I wanna be
able to print a student ID number followed by the information
about the person. And my first version of this code
will look something like this. So return this getSID then a colon,
and then this.getName. And the concern I would have here
is what if the person changes. So the only reason I wrote this dot
getName right now is because I know that's person does. So if you try to call toString on person,
it prints the name. But Person could change. So this really isn't
the right way to do it. What I want to do instead is call
the toString method within Person and to do that I wanna use that super keyword, just like we saw from the constructors to
say, I want the method from my superclass. So now, if we walk through this code
I'm gonna use Student s = new Student. I'm gonna print out that which is
gonna call the toString method. A question is what do we
expect to see happen. Well, we expect to see the student
ID number now followed by the name, which is exactly what we
wanted to have happen. What happens now if I
change the referencing? What if I make the reference
a Person instead of a Student? And I still pass, I still try to
call s.toString, on that Person. Is it gonna call the Student
to string method or is it gonna call the person
to string method? Well what do we want to have happen? We want to have it print out
the student information, which is exactly what it does. Why is it gonna print the student method? Because of polymorphism, and
we'll get into that in the next lesson.So in this lecture we're talking
about arrays and linked lists. In this video,
we're going to talk about arrays. So here's some examples of declarations of
arrays in a couple of different languages. Along with, we can see the one dimensional
array laid out with five elements in it, and then a two dimensional array with one
row, sorry two rows and five columns. So what's the definition of an array? Well we got basically
a contiguous array of memory. That is one chunk of memory. That can either be on a stack or
it can be in the heap, it doesn't really matter where it is. It is broken down into
equal sized elements, and each of those elements are indexed
by contiguous integers. All three of these things
are important for defining an array. Here, in this particular example, we have
an array whose indices are from 1 to 7. In many languages, the same indices for this particular array
would be from zero to six. So it would be zero based indexing, but one based indexing is also
possible in some languages. And other languages allow you to actually
specify what the initial index is. What's so special about arrays? Well, the key point about an array
is we have random access. That is, we have constant time access
to any particular element in an array. Constant time access to read,
constant time access to write. How does that actually work? Well basically what that means is we
can just do arithmetic to figure out the address of a particular array element. So the first thing we need to do is
start with the address of the array. So we take the address of the array and then we multiply that by
first the element size. So this where the key part that every
element was the same size matters, so that allows us to do
a simple multiplication. Rather than if each of the array
elements were of different sizes, we'd have to sum them together, and
if we had to sum together n items, that would be order n time. So we take our array address, we add
to it the element size times i which is the index that's of interest
minus the first_index. If we're doing zero based indexing,
that first index isn't really necessary. I like this example because it really
shows a more general case where we do have a first index. Let's say for instance we're looking
at the address for index four. We would take four minus the first index,
which is one, which would give us three. Multiply that by whatever
our element size is, and then add that to our array address. Now of course, we don't have to do this
work, the compiler or interpreter does this work for us, but we can see how
it is that it works in constant-time. Many languages also support
multi-dimensional arrays, if not you can actually kind of roll your
own through an example I'll show you here, where you do your own arithmetic. So here, let's look. Let's say that the top left element is at
index (1, 1), and here's the index (3,4). So this means we're in row 3, column 4. How do we find the address
of that element? Well, first off what we need
to do is skip the rows that, the full rows, that we're not using. So that is,
we need to skip two rows, or skip 3, which is the row index minus 1,
which is the initial row index. So that gives us 2 times 6 or
12 elements we're skipping for those rows in order to get to row 3. Then we've got to skip the elements
before (3,4) in the same row. So there are three of them. How do we get that? We take the column index, which is 4 and subtract it from
the initial column index which is 1. So this basically gives us 15. Six for the first row, six for
the second row and then three for the third row before
this particular element. We take that 15 and
multiply it by our element size and then add it to our array address. And that will give us the address
of our element (3,4). Now we made kind of a supposition here. And that was that the way this was laid
out is we laid out all the elements of the first row, followed by all of
the elements of the second row, and so on. That's called row-major ordering or
row-major indexing. And what we do is basically, we lay out,
(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6). And then right after that in memory (2,
1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6). So the column index is changing
most rapidly as we're looking at successive elements. And that's an indication
of it's row-major indexing. We could lay out arrays differently,
and some languages or compilers actually do that, where they
would lay out each column in order, so you'd have the first column, then the
second column, and then the third column. And so that, then, the successive
elements would be (1, 1), (2, 1), (3, 1), followed by (1,
2), (2, 2), (3, 2), and so on. So there we see that the row index
is changing most rapidly, and this is called column-major ordering. How long does it take
to perform operations? We already said to read any
element is O(1), and to write any element is O(1). That is a standard feature of arrays. What happens if we want to add
an element at the end of an array? So let's say we have allocated
seven elements for an array. We're only using four of them, okay? So we have kept track that we're using
four and we want to add a fifth element. And again there's room for seven. Then all we know it was just add it, then update the number of
elements that are in use. That's an O(1) operation. If we want to remove
the last element as well, that's an O(1) operation because we just update the number of elements that are in
use, and so that's an O(1) operation. Where it gets to be expensive,
is if we want to, for instance, remove the first element. So we remove the five here, and what we've got to do then,
we don't want to have holes left in it. So we need to move the 8 down,
move the 3 down, move the 12 down. That's an O(n) operation. Same thing would happen if he
wanted to insert at the beginning. So we would need to move the 12, move
the 3, and move the 8 to make space for our new element. So that also would be O(n). And if we want to add or remove somewhere in the middle,
again that's an O(n) operation. If we want to add exactly in the middle, we have to move n/2 items,
which is O(n). Same thing for removal. So arrays are great if you want or
remove at the end. But it's expensive if you want to add or
remove in the middle or at the beginning. However, remember,
a huge advantage for arrays is that we have this constant time
access to elements, either read or write. In summary then, an array consists
of a contiguous area of memory. because if it were non-contiguous then we
couldn't just do this simple arithmetic to get where we're going. We have to have equal-size elements
again so our arithmetic works. And indexed by contiguous integers
again so our arithmetic works. We have constant time access to
any element, constant time to add or remove at the end and linear time to add
and remove at any arbitrary location. In our next video we're going to
talk about linked lists.Now let's talk about linked lists. So linked lists, it's named kind of
like links in a chain, right, so we've got a head pointer that points
to a node that then has some data and points to another node,
points to another node and eventually points to one that
doesn't point any farther. So here in our top diagram we show
head points to the node containing 7, points to the node containing 10,
points to the node containing 4, points to the node containing
13 doesn't point anywhere. How this actually works is that
a node contains a key which in this case is these integers,
and a next pointer. The diagram below shows more
detail of what's going on. So head is a pointer
that points to a node, and that node contains two elements,
the value 7. And then a pointer that points off to
the next node that contains a key 10, and a pointer that points
off to the next node 4, points off to the next node 13,
13's next pointer is just nill. What are the operations that
can be done on a linked list? There's several of them, and the names
of these sometimes are different, in different environments and
different libraries. But normally the operations
provided are roughly these. So we can add an element to
the front of the list, and that we're calling PushFront. So that takes a key,
adds it to the front of the list. We can return the front
element of the list. We're calling that TopFront. Or we can remove the front element
of the list, called PopFront. The same things that we can
do at the front of the list, we can also do at the end of the list. With PushBack, later on in a later module, we'll actually use the word Append for
that, or TopBack, or PopBack. These seem uniform in there, but
there is a difference in that the runtimes are going to be different between those,
and we're going to talk about that. You can find whether an element is in the
list and it's as simple as just running yourself down the the list
looking to find a matching key. You can erase an element and then again
run yourself down the list til you find the matching key and
then remove that element. So these latter ones
are both O(n) time. Is the list empty or not? That's as simple as checking
is the head equal to nil. We can add a particular key--if we
want to splice in a key into a list we can actually add in a key either before
a given node or after a given node. So lets look at the times for
some common operations. We've got here our list
with four elements in it: 7, 10, 4, and 13. Now we go ahead and
push an element to the front. So we push 26 to the front of the list. So the first thing we do, create a node
that contains the 26 as its key. And then we update our
next pointer of that node to point to the head,
which is the 7 element, and then update the head pointer to point to
our new node, and that's it we're done. So it's O(1). Allocate, update one pointer,
update another pointer, constant time. If we want to pop the front element, clearly finding the front
element is very cheap here, right? You can just look at the first element and
return it. So TopFront is O(1). PopFront turns out is
going to be O(1). First thing we're going to do,
update the head pointer. Then, remove the node. That's an O(1) operation. If we want to push at the back,
and we don't have a tail pointer, we're going to talk about
a tail pointer in a moment, then it's going to be
a fairly expensive operation. We're going to have to start at the head
and walk our way down the list until we get to the end, and add a node there,
so that's going to be O(n) time. Similarly if we want to TopBack or
PopBack, we're going to also have to start at the head,
walk our way down to the last element. Those are all going to be O(n) time. If we had a tail pointer,
some of these will become simpler. Okay, so, we're going to have both a head
pointer that points to the head element and a tail pointer that
points to the tail element. So, that way,
getting the first element is cheap. Getting the last element is cheap. Let's look at what happens when we
try an insert when we have a tail. We allocate a node,
put in our new key, and we then update the next pointer of the
current tail, to point to this new tail. And then update the tail pointer itself. O(1) operation. Retrieving the last element, so a PopBack, sorry a TopBack,
is also an O(1) operation. We just go to the tail,
find the element, return the key. If we want to pop the back however that's
a little bit of an expensive operation. Okay. We are going to need to update
the tail to point from 8 to 13 so we're at 8 right now we want to go to 13,
the problem is how do we get to 13? Okay. We don't have a pointer from 8 to
13 we have a pointer from 13 to 8. And that pointer doesn't
help us going back. So what we've got to do is, again, start at
the head, walk our way down until we find the 13 node that then points
to the current tail, and then update our tail pointer
to point to that, and then update the next pointer to be nil. And then we can remove that old one. So that's going to be an O(n)
operation. because we've got to walk
all the way down there. Okay, because even though we have a tail
pointer we don't have the next to the tail pointer, we don't have
the next to last element. The head is different because our pointers
point this way, if we had the head Its also cheap to get the second element,
right, and one more to get the third element but the tail pointer doesn't help
us get to the next to the last element. Let's look at some of the code for this,
so for PushFront we have a singly linked list: we're going to allocate a new node,
set its key, set its next to point to the old head and then
we'll update the current head pointer. If the tail is equal to nil, that meant
that before the insertion, the head and the tail were nil, it was an empty list. So we've got to update the tail to
point to the same thing the head points to. Popping the front, well, if we're asked to pop the front on
an empty list, that's an error. So that's the first check we do here and then we just update the head to
point now to the head's next. And just in case that there was
only one element in the list and now there are no elements,
we check if our new head is nil and if so update our tail to also be nil. Pushing in the back: allocate a new node,
set its key, set its next pointer, and
then check the current tail. If the current tail is nil again,
it's an empty list. Update the head and
the tail to point to that new node. Otherwise update the old tail's
next to point to our new node, and then update the tail
to point to that new node. Popping the back. More difficult, right. If it's an empty list and
we're trying to pop, that's an error. If the head is equal to tail,
that means we have one element. So we need to just update the head and
the tail to nil. Otherwise we've got to start at the head,
and start working our way down, trying to find the next
to the last element. When we exit the while loop,
p will be the next to last element, and we then update its next pointer to nil. And set our tail equal to that element. Adding after a node? Fairly simple in a singly linked list. Allocate a new node, set its next pointer to whatever node
we're adding after, to its next. So we sort of splice in, and
then we need to update the node pointer. The one we're adding after, so
that it points now to our new node. And just in case that node we're adding
after was the tail we've got to now update the tail to that new node. Adding before, we have the same problem
we had in terms of PopBack in that we don't have a link back
to the previous element. So we have no way of updating its
next pointer other than going back to the beginning of the head and
moving our way down until we find it. So AddBefore would be
an O(n) operation. So let's summarize what
the cost of things are. PushFront, O(1). TopFront, PopFront, all O(1). Pushing the back O(n) unless we have
a tail pointer in which case its O(1). TopBack O(n), again unless we have
a tail pointer in which it's O(1). Popping the back: O(n) operation,
with or without a tail. Finding a key is O(n) we just walk
our way through the list trying to find a particular element. Erasing, also O(n). Checking whether it's empty or not is as
simple as checking whether the head is nil. Adding before: O(n) because
finding the previous element takes O(n) because we're going to
walk all the way from the head to find it. AddAfter: constant time.There is a way to make popping
the back and adding before cheap. Our problem was that although
we had a way to get from a previous element to the next element,
we had no way to get back. And what a doubly-linked list says is,
well, let's go ahead and add a way to get back. So we'll have two pointers,
forward and back pointers. That's the bidirectional arrow
we're showing here conceptually. And the way we would
actually implement this is, with a node that adds an extra pointer. So we have not only a next pointer,
we have a previous pointer. So this shows for
example that the 10 element has a next pointer that points to 4 but
a previous pointer that points to 7. So at any node we can either go forward or
we can go backwards. So that means if we're trying to pop the
back, that's going to work pretty well. What we're going to do is update the tail
pointer to point to the previous element because again we ca get
there in an O(1) operation. And then update its next pointer to be
nil and then finally remove the node. So that's O(1). So if we have a doubly linked list it's
slightly more complicated (our code) because we've got to make sure to manage both
prev pointers as well as next pointers. So if we're pushing something in the back,
we'll allocate a new node. If the tail is nil, which means it's
empty, then we just have a single node whose prev and next pointers are both nil
and then head and tail both point to it. Otherwise, we need to 
update the tail's next pointer for this new node,
because we're pushing at the end and then go update the prev pointer of this
new node to point to the old tail and then finally update the tail
pointer itself. Popping the back,
also pretty straightforward. We're going to again check to see whether
this is first an empty list, in which case it's an error. A list with only one element,
in which case it's simple. Otherwise we're going to go ahead and update our tail to be the prev tail,
and the next of that node to be nil. Adding after, fairly simple again we just
need to maintain the prev pointer but adding before also now works in
the sense that we can allocate our node, our new node and its prev pointer will be the prev pointer
of the existing node we're adding before. We splice it in that way and then we'll update the next pointer of that
previous node to point to our new node. And finally,
just in case we're adding before the head, we need to update the head. So in a singly-linked list,
we saw the cost of things. Working with the front
of the list was cheap, working with the back of the list
with no tail, was all linear time. If we added a tail,
it was easy to push something at the end, easy to retrieve something at the end,
but hard to remove something at the end. By switching to a doubly linked list, removing from the end (a PopBack)
becomes now an O(1) operation, as does adding before which used
to be a linear time operation. One thing to point out as we
contrast arrays versus linked lists. So in arrays, we have random access, in a sense that it's constant
time to access any element. That makes things like
a binary search very simple, where we start searching in the middle,
and then tell (if we have a sorted array), and then can decide which
side of the array we're on. And then, go to one side or the other. For a linked list, that doesn't work. Finding the middle element
is an expensive operation. because you've got to start either
at the head or the tail and work your way into the middle. So that's an O(n) operation
to get to any particular element. Big difference in between that and
an array. However, linked lists are constant time
to insert at or remove from the front, unlike arrays. What we saw in arrays,
if you want to insert from the front, or remove from the front, it's going to take you
O(n) time because you're going to have to move a bunch of elements. If you have a tail and doubly-linked, it is also constant time to
work at the end of the list. So you can get at or remove from there. It's linear time to find
an arbitrary element. The list element are not contiguous
as they are in an array. You have separately allocated
locations of memory and then there are pointers between them. And then, with a doubly-linked list
it's also constant time to insert between nodes or to remove a node.So now we're going to start talking about
two very important data structures, stacks and queues. In this video we're
going to talk about stacks. So, what is a stack? It's an abstract data type, and
here are the operations we have. We can push a key, so we've got
a collection of values and we can push it. We can find the most recently
added key with Top. And we can Pop, which returns and
removes the most recently added. So, the way to think of it is
as if you have a stack of books. You can put a book on top of the stack, or you can take a book from
the top of the stack. But you can't take the element at
the bottom of the stack of books without taking off all of the previous elements. So it's really pretty simple. Push items on,
you can find what the top one is. You can pop off the top one and
you can intermingle these operations. Last one: you can find is is it empty? So are, do we have an empty stack? This turns out to be really useful for
lots and lots of things, where you need to be keep track of what
has happened in this particular order. Let's look at an example. So let's say we've got
a balanced brackets problem. So, here we have a string. And it has left parens, right parens,
left square brackets, and right square brackets. And we want to determine whether or
not that string of parentheses and square brackets, whether they're balanced. And balance meaning there's a matching
left paren for every right paren. And they're in the right order. And they don't cross over. Let's look at some examples
of unbalanced and balanced. So, the first string here left paren,
square bracket, matching square bracket,
matching right paren, square bracket, matching square bracket, left paren,
matching paren, balanced. The second one also balanced. The unbalanced one for example here a left
paren with no matching right paren. Assuming that the two parens on the
right side are matching themselves. The square brackets match, but then we
have got an unmatched right bracket. In the last case we've got a square left
bracket and a square right bracket, but the problem is that they
are in the wrong order. It is the square right bracket
followed by the square left bracket. How do we keep track of that? And the problem is that in some cases we
have to kind of keep track of a lot of information. For instance, in the second example,
here, we've got our opening left paren. Doesn't get matched with
the right paren for quite a while. There's a lot of intervening stuff,
and we have to sort of keep track that we've got a left paren whose
right paren we need to match, even as all this other stuff happens. And it turns out a stack is a good way to
keep track of it, so here's what we'll do. We'll create a stack and then we'll go
through every character in the string. If we have an opening paren or an opening square bracket,
we'll go ahead and push it on the stack. So the stack is going to represent
the parens that are still open, the parens and brackets which have yet
to be matched and the order in which they need to be matched, so the outermost ones
will be at the bottom of the stack and the last one we saw (the innermost one)
would be at the top of the stack. Then if it's not one
of these opening ones. Then if our stack is empty then
that's a problem, because basically we've got a closing paren or bracket and
there's no matching element. So if the stack is empty, no, we're not balanced. Otherwise we'll pop the top element
off and then we'll check and see. Does it match, an element from the stack,
does it match the character we've got? So, if the top was a left paren,
did we just read a right paren. If so, great. They match. And now those two match, the next one we need to match is
still the newly top one on the stack or similarly if we have a square bracket on the
stack and a square bracket we read, those match as well. If they don't match,
then we've got a problem, right? If we've got a right paren on the stack
and a, sorry a left paren on the stack and right bracket that we just read,
those don't match for example. So then we return false. Once we've run through all of the strings,
were matched, right? No.
Not necessarily. Imagine we have the string,
left paren, left paren, left paren.. We go through, we push left paren,
we push left paren, we push left paren and then we'd be done. It won't ever return false, but, it's no good because we didn't
actually match what's on the stack. So, once we go through all of
the characters in the string, then we're going to have to check and
make sure, is our stack empty? Did we successfully match everything? This is only one example
of the use of stacks. Stacks are used in lots of other places. They're used for compilers. They're used in a lot of algorithms that
you'll be seeing throughout this course. So how do you actually implement a stack? Well, let's see. You can implement a stack with
an array fairly easily, so allocate an array of
some maximum stack size. So, in this case, we decided it's five,
just for the sake of example, and we're going to keep a variable, which is the number of elements
that are actually in the stack. When we push, so in this case we going to
push a, we're going to go ahead and put it at the end of the array,
that we've got so far. So, for whatever elements we have,
we'll append it to those. So in this case, we will put it at the beginning of the
array because we haven't used any elements. And we will kept track of
the number of elements, as well. We push b, put in the next spot and
now our number of elements is two, fairly straight forward, right,
we're just appending to the array and these are clearly O(1) operations. What's the top element? Well that's really simple. If the number of elements is two, that means we need the second
element from the array. Which in this case, is b. Again, a constant time operation. We push c, our number of elements is three,
and now let's say we pop. Well, what do we do? We need to go get the third element,
which is c, and erase it, and then adjust numElements so it's now 2. Now we can push an element,
push another element, push a fifth element, and now if we try
to push again, that's an error, right? Because we don't have any more space. So, that wouldn't be allowed. Is it empty?
No, how do we know? Because the number of
elements is greater than zero. Again, an O(1) operation. And now we can start popping,
which will be returning the appropriate element of the array
based on the numElements value, and keep popping until we
get down to no elements. If we're at no elements,
and we ask it's empty? Yes. That's true. We can also implement
a stack with a linked list. So, one disadvantage--one
limitation--of the array is that we have a maximum size,
based on the array we initially allocated. But all of the operations are
O(1), which is good. The other potential problem is that
we have potentially wasted space. So if we allocated a very large array,
to allow a possibly large stack, we didn't actually use much of it,
all the rest of it is wasted. If we have a linked list,
what we do then is every element in the list of course will represent
a particular element in the stack. And so we'll push a, and then if we
push b, we're going to go ahead and push b at the front. So basically,
pushes will turn into PushFront. If we want to get the top element,
just get the head element, so top will really just be TopFront,
we can keep pushing. Pushing at the front or popping,
All of those are O(1) operations. We can keep pushing, and the nice thing
about this is there's no a priori limit as to the number of elements you can add. As long as you have available memory,
you can keep adding. There's an overhead though,
like in the array, we have each element size,
is just big enough to store our key. Here we've got the overhead
of storing a pointer as well. On the other hand there's
no wasted space in terms of allocated space that isn't actually
being used. So we keep pushing, is it empty? No, because the head is not nil. And
then we can go ahead and pop, so, if we had a linked list it's very
simple to implement the stack operations in terms of
the linked list operations. Push becomes PushFront. Top becomes TopFront and Pop which
is supposed to both return and pop the top element then become a combination
of a TopFront followed by a PopFront. Empty is just Empty. We keep popping and then eventually
we pop the last element and now if we ask whether it's empty,
the answer will be true. Okay, so that's our stack implementation. Stacks can be implemented with either arrays or
linked lists, I talked a little bit about the pros and cons of each of those, the
linked list has fixed amount of overhead, that is for every element you are pushing,
you have an additional pointer. For arrays you have, potentially,
space that you've over-allocated, basically, to allow for
a stack to grow to maximum size. For arrays, stacks do have a maximum size. For linked lists, they don't. Each stack operation is constant time
for either one of these implementations. Sometimes we know stacks as LIFO queues. LIFO meaning Last In First Out. The last one that was inserted Is
the first line that comes out. This reminds me sometimes of also
what's known as GIGO, Garbage In Garbage Out. That if you input garbage into a system,
you get garbage out. But of course this is different. So that is stacks. In the next video we're going to
go ahead and look at queues. Thanks.Now let's talk about queues. So, a queue has some
similarities with a stack. But in a fundamental way is different. So it's an abstract data type and
these are the operations that it has. You can Enqueue a key,
it adds the key to the collection. And then when you Dequeue, that gives you
back a key and removes it from the queue. It removes and
returns the least recently added key, rather than in the case of a stack,
the most recently added key. So that's the fundamental difference. If you think about queues as
like queuing up in line or waiting in line, this is a first
come first serve situation. So the longer you've been waiting in line,
so the longest person waiting in line
is the next person to be served. Makes sense. So you can imagine if you
had a grocery store that had a stack that it used for serving people,
people would be pretty annoyed, right? Because the person who'd just arrived, you've been waiting in line ten minutes,
a person just arrives, they get served before you do,
that would not make you happy. So, queues are very useful for instance,
for things like servers. Where you've got a bunch
of operations coming in and you want to service the one
that's been waiting the longest. The other operation is you can find
out whether the queue is empty or not. So these are often called FIFO,
first in, first out, and this distinguishes them
from stacks which are LIFO. Last in, first out. First in first out, or
first come first serve, same thing. How can you implement a queue? Well, one way is with a linked list,
where you have a head and a tail pointer. So let's say we start out
with an empty linked list. We can go ahead and Enqueue, and what
we're going to do basically in an Enqueue, is we are going to push to
the back of the linked list, so that's how we'll implement Enqueue. So here, we Enqueue (a), it's now at
the back of the linked list. If we Enqueue (b),
it's going to be then added, again, at the end of the linked list. Is it empty?
No. How do we know it's not empty? Well the simplest thing is we would just
call to the underlying list implementation and say hey, list are you empty? It would say no. And so empty for the queue is no. We know it's really happening just by
checking whether the head is nil or not. If we Enqueue(c) then,
again it goes to the tail of the list. And if I now Dequeue,
which one is going to be removed? Again this is not a stack,
in a stack c would be removed. In our case, (a) is going to be removed
because it's been there longest. That's just an implementation
of popping from the front. So that would return (a). We can now do some more Enqueueing,
Enqueue(d), Enqueue(e), Enqueue(f), and now if we start
Dequeueing, we Dequeue from the front. So Dequeuing (b), Dequeuing (c),
Dequeuing (d), Dequeuing (e), and finally Dequeuing (f). If we ask whether the queue is empty now,
the answer is yes. Again, because the head is nil. So Enqueue uses list's PushBack call and
Dequeue uses both the list's TopFront to get the front element as well
as PopFront to remove that front element. And Empty just uses the list's Empty method. What about with an array? We could think of doing something similar. That is, we could add at the end and
then pop from the front. But you can imagine, so, we said the front of the array
is the beginning of the queue. Then enqeueing is easy, but dequeuing
would be an expensive O(n) operation. And we want enqeueing to be O(1). We can do that, in a fashion I'll
show you right now which is basically keeping track of sort of
the array as a circular array. So we're going to go ahead and
Enqeue (a), and we have a write index. And the write index tells us where the
next Enqueue operation should happen. And the read tells us where the next
Dequeue operation should happen. So we Enqueue a, we Enqueue b,
and now update our write index. If we ask whether we're empty? No, we're not empty because
read is not equal to write. That is we have something to
Dequeue that has been Enqueued. So Empty would be false. We Enqueue (c), we Dequeue,
again we're going to Dequeue (a), so we Dequeue from the read index. So we basically read what's at the read
index and then increment the read index. If we now Dequeue again, we read what's
at the read index which is (b) and we increment the read index. Now we will do some more Enqueueing. Notice at this point that when we
Enqueue(d), the write index is 4, that's the next place we're going to
Enqueue(e), which will have us write to the index 4 and then the write index
wraps back around to the initial element. And, here it's important to note we're
using zero based indexing with this array because of the fact that
the first element is zero. We Enqueue again, Enqueue (f), and now if we try Enqueue (g),
it's not going to allow us to do that. So that will be an error. The reason it would be an error,
is if we did Enqueue(g), the read and the write index would be both be 2. And it would be hard to distinguish read
and write index 2 because the queue is full, or read and write index
both 2 because the queue is empty. So therefore, we have a buffer of at least
one element that can't be written to, to make sure read and
write are separate and distinct if the queue's not empty. Now we'll Dequeue, so
we'll Dequeue (c), basically reading from the read index and updating it. Dequeue (d),
read from the read index and update it. Dequeue (e) and here again,
the read index wraps around back to 0. And now finally, we do our final
Dequeue and now the read and write index are both 1. Which means if we ask whether Dequeue is
empty, the answer is yes, it is empty. So what we see here is that the cost for
doing a Dequeue and an Enqueue, as well of course as Empty,
are all O(1) operations this way. So we can use either a linked list, although we have to have a tail pointer,
so that PushBack is cheap, or an array. Each of the operations is O(1). One distinction between the array and
the linked list implementation, is that in the array implementation, we have
a maximum size that the queue can grow to. So it's bounded. Maybe you want that in which case
it's fine, but if you don't know a priori how long the queue you need is
going to be an array is a bad choice. And any amount that is
unused is wasted space. In a queue that's implemented
with a linked list, it can get arbitrarily large as
long as there's available memory. The downside is, every element you
have to pay for another pointer.Okay, in this next video we'll layer on
some more details of building classes in Java. We're gonna talk about the keywords public
and private and protecting your data and methods inside your classes. So by the end of this video you'll be able
to describe what those keywords mean and their effect on who can access the data
and methods inside your classes. And you'll be able to also talk
about how to use getters and setters to allow customized access
to the data inside of your classes. So as usual, we're gonna go back to the SimpleLocation
class that we've been developing. So these class, as you know, has two
member variables, latitude and longitude. And we originally declared
them both to be public. So let's take a closer
look at what that means. What that means is that anyone can
access these member variables from any class at all. So when I create a new object
of type SimpleLocation, I can get at the member
variable latitude or the member variable longitude to read
its value or to change its value. So if I go over here into
the LocationTester class, I see that I've created two
new SimpleLocation objects. I can change the value of latitude
inside the object stored in lima. That's totally okay, because that member
variable is declared to be public. So I can access it from anywhere. Similarly for methods, I've declared
my method distance to be public. Which means that I can
access that method anywhere. So over here, back in my LocationTester
class I'm calling the distance method, which is also totally allowed because
again, that method is public. On the other hand, if I were to
declare my member variables private, what that would mean is that those
variables would only be accessible from within the SimpleLocation
class itself. So only inside this class definition. Nowhere else. No one else has access to either read or
write those variables. Same thing goes for methods. If I make a method private, I can only call that method within
the class I'm defining, and nowhere else. So, if we look at what that means, if we look at this constructor,
these two lines of code are just fine. I'm using this.latitude to access
the member variable latitude and this.longitude to access
the member variable longitude. Perfectly okay because I'm
inside the class SimpleLocation. However, if I go back to that
class LocationTester, and look at this line here that's trying
to change the value of latitude in the SimpleLocation stored in the variable
lima, that's no longer allowed. Because now I've said that that
latitude variable is private. It can only be accessed from
within the SimpleLocation class. And we're no longer in
the SimpleLocation class. We're now over here in the main method,
inside LocationTester. So that would cause an error. So, it's actually,
despite this error that just got caused, it's actually a good idea to make
your member variables private. Because you as the class designer
want to really have ultimate control over who gets to see and change the data that's stored in each
object of the class that you're creating. So as a rule of thumb,
always make your member variables private. Now methods can either be public or private, depending on whether they're for
world use, like the distance method. Or whether they're maybe just helper
methods that are designed to be used only within that class itself. We'll talk more about that as we start
talking about more sophisticated class design. But, for now, let's focus on this rule
of thumb that we should make our member variables private. So, if our member variables are private,
nobody else can access them. They can't see their values,
they can't change them. So, that seems like a bit of a problem. We probably sometimes want to
give a little bit more access to the member variables
in our class than that. So the way we get around that problem is
through the use of what are called getters and setters. So this is an example right here of a
getter, and the purpose of a getter is to take the value of a member
variable that's private and expose it outside of that class. So you can see this getter here gets
the value of the member variable latitude, which is private, and
returns it to the outside world. So the variable itself
is still private but now I can gain access to that
variable by calling this getter. So if we go back over here to the code,
we can see that if I try to access the variable directly say,
print it out I get an error, but when I call that getter method,
that's perfectly fine. So I can actually get access to
the value of that latitude variable through the getter. And now notice that in this code so far,
going back here, I haven't provided my user of my class with any way to actually
set or change the value of latitude. And that may be what I intend as the class
designer, that once that latitude variable gets set in the constructor, I may
never want anybody to change it again. And in that case,
I would just simply provide a getter and not provide any way for the user to
change the value of the variable. But, let's say I actually do
want to allow somebody to change the value of the variable. In that case I would provide
what's called a setter. So, here's my setter. What it does is it takes in a value, lat,
and it changes the value of the private member variable to the value
that was passed in by the user. So a setter sets the value
of our member variable, usually a private member variable. So now I've got a getter and
a setter for my latitude variable. And you might be thinking,
I would be thinking if I were you, why didn't we just make that
member variable public? If we're exposing
the ability to change it and read it, we might as well
just make it public, right? So here's why, having the getter and the setter allows us more
control as class designers. So let's say we want to allow the user
to change the value of the latitude. But we're little bit unsure that the user
of our class will know what they're doing when it comes to legal latitude values. So we can put some precautions in place
that allow the user to change the value of that latitude, but only to values
that are legal latitude values. So the way we would do this is we would
modify our setter to rather than just blindly accepting whatever argument was
passed in, we would have some checks, some logic inside of that method
that said okay, if it's out of range of -180 to 180 then
that's not a legal value. So we're gonna print out an error,
inform the user of our class that, hey, you tried to set your latitude
variable to an illegal value. That's probably some bug in your code, so
you should probably go check that out. And not change the value that's
stored in the latitude variable. Otherwise, we can happily accept the value
because it's within the legal range and change the value of that variable. All right, so that's it for
the details of classes and objects. You now know all the basics of
creating classes and objects. Next you'll take a short practice quiz and
then move on to the next module.In this lecture,
we're going to talk about trees. Let's look at some example trees. So here we have a sentence,
"I ate the cake". Now, we're going to look
at a syntax tree for that, which shows the structure of the sentence. So it's similar to sentence diagramming
that you may have done in grade school. So we have at the top of the tree,
the S for sentence and then children:
a noun phrase and a verb phrase. The child of the noun phrase is
the word I from the sentence. And the child of the verb phrase is a verb
and noun phrase, where the verb is ate, and the noun phrase is a determiner and
a noun, the and cake. So along the bottom of the tree,
we have the words from the sentence, "I ate the cake", and the rest of the tree
reflects the structure of that sentence. We can look here at a syntax tree for
an expression  2sin(3z-7), we can break that up into the structure. So at the top level,
we have a multiplication, that's really the last thing that's done,
multiplying the 2 and the sine. Within the sine,
what we're applying the sine to is 3z-7, so we have the minus that's happening last
with a 7 and then this 3z, 3 times z. So this shows again the structure
of the expression and the order in which you might evaluate it. So from the bottom, you would first do 3
times z, and then you would subtract 7 from that, you'd apply the sine to that,
and then you multiply that by 2. Trees are also used to reflect hierarchy. So this reflects hierarchy of geography
where we have at the left hand side the top level of the hierarchy, the world. And then below that, entities in the world, United States,
all sorts of other things, United Kingdom. And then below that,
various subcomponents of the geography. So we've got, for
the case of the United States, states, and then within those states, cities. Another example of a hierarchy
is the animal kingdom. This is part of it where we've got
animals, and then below that, different types of animals, so invertebrates,
reptiles, mammals, and so on. And then within each of these,
we have various subcategorizations. So this shows this entire hierarchy. We also use trees in computer science for
code. So in order to represent code, we will
do that with an abstract syntax tree. So our code here is a while loop. While x is less than 0, x is x+2, f of x. So we reflect that at the top,
we have while, which is our while loop. And the children of the while loop
are the condition that needs to be met for the while loop to continue and
then the statement to execute. So the condition is x less than 0, so
comparison operation, the variable x and the constant 0. And then the statement to execute, well,
it's actually multiple statements so we have a block. And in those blocks, we have two different
statements, an assignment statement and a procedure call. The assignment statement, the left child
is the variable we're assigning to, which is x, and the right child is
an expression, in this case, x+2. The procedure call, the left child
is the name of the procedure, and subsequent children
are the arguments to that procedure. In our case, we just have one argument x. Binary search tree is a very common
type of a tree used in computer science. The binary search tree is defined
by the fact that it's binary, so that means it has at most
two children at each node. And we have the property
that at the root node, the value of that root
node is greater than or equal to all of the nodes
in the left child, and it's less than the nodes
in the right child. So here less than or greater than,
we're talking about alphabetically. So Les is greater than Alex,
Cathy, and Frank, but is less than Nancy, Sam,
Violet, Tony, and Wendy. And then that same thing is true for
every node in the tree has the same thing. For instance, Violet is greater than or
equal to Tony and strictly less than Wendy. The binary search tree allows
you to search quickly. For instance, if we wanted to search in
this tree for Tony, we could start at Les. Notice that we are greater than Les,
so therefore, we're going to go right. We're greater than Sam so we'll go right. We're less than Violet so
we'll go left and then we find Tony. And we do that in just four comparisons. It's a lot like a binary
search in a sorted array. So with all these examples of trees,
what's the actual definition of a tree? Well a tree is,
this is a recursive definition. A tree is either empty or
it's a node that has a key and it has a list of child trees. So if we go back to our example here,
Les is a node that has the key Les and two child trees, the
Cathy child tree and the Sam child tree. The Cathy child tree is
a node with a key Cathy and two child trees, the Alex child tree and
the Frank child tree. Let's look at the Frank child tree. It's a node with a key Frank and two,
well, does it have any child trees? No, it has no child trees. So let's look at some other examples. An empty tree, well, we don't really
have a good representation for that, it's just empty. A tree with one node is the Fred tree,
and it has no children. A tree with two nodes is a Fred
with a single child Sally, that in itself has no children. In computer science commonly, trees grow
down, so parents are above their children. So that's why we have Fred above Sally. So let's look at some other
terminology for trees. So here, we have a tree,
Fred is the root of the tree. So it's the top node in the tree. And here, the children of Fred are Kate,
Sally, and Jim. We are actually showing that with arrows,
commonly, when you show trees, you don't actually show the arrows. We just assume that if a node
is above another node, that it's a parent of that node. A child has a line down
directly from a parent, so Kate is a parent of Sam,
and Sam is a child of Kate. An ancestor is a parent or
parent's parents and so on. So Sam's ancestors are Kate and Fred. Hugh's ancestors are also Kate and Fred. Sally's ancestors are just Fred. The descendant is an inverse of
the ancestor, so it's the child or child of child and so on. So the descendants of Fred are all of
the other nodes since it's the root, Sam, Hugh, Kate, Sally and Jim. The descendants of Kate
would just be Sam and Hugh. Sibling, two parents, sorry, two nodes sharing the same parent, so
Kate, Sally and Jim are all siblings. Sam and Hugh are also siblings. A leaf is a node that has no children. So that's Sam, Hugh, Sally, and Jim. An interior node are all
nodes that aren't leaves. So this is Kate and Fred. Another way to describe it is
all nodes that do have children. A level: 1 plus the number of
edges between the root and a node, let's think about that. Fred, how many edges are there
between the root and the Fred node? Well, since the Fred node is the root,
there are no edges. So its level would be 1. Kate has one edge between Fred and Kate, so its level would be 2,
along with its siblings, Sally and Jim. And Sam and Hugh are level 3. The height: the maximum depth of
the subtree node in the farthest leaf, so here we want to look, for instance,
if we want to look at the height of Fred, we want to look at what is
its farthest down descendant. And so its farthest down
descendant would either be Sam or Hugh. Its height would be 3. So the leaf heights are 1. Kate has height 2. Fred has height 3. We also have the idea of a forest. Extending this tree metaphor,
so it's a collection of trees. So we have here two trees with a root Kate
and a root Sally, and those form a forest. So a node has a key, children, which is a list of children nodes, and
then it may or may not have a parent. The most common representation probably
of trees, is really without the parent. But it's possible to also have parent
pointers, and that can be useful as a way to traverse from anywhere in a tree to
anywhere else by going up and then down, following parent nodes and
then child nodes. On rare occasions, you could have a tree that's
represented just with parent pointers. Okay, but that's unusual because a lot
of times, kind of the way you get access to a tree is via its root and
you want to go down from there. There are other less commonly used
representations of trees as well, we're not going to get into here. Binary trees are very commonly used. So a binary tree has,
at most, two children. Rather than having in this general
list of children, for a binary tree, we normally have an explicit left and
right child, either of which can be nil. As with the normal tree,
the general form of a tree, you may or may not have a parent pointer. Let's look at a couple of
procedures operating on trees. Since trees are recursively defined,
it's very common to write routines that operate on trees
that are themselves recursive. So for instance, if we want to calculate the height of
a tree, that is the height of a root node, we can go ahead and recursively do that,
going through the tree. So we can say, for instance, if we have
a nil tree, then its height is a 0. Otherwise, we're 1 plus the maximum of the
left child tree and the right child tree. So if we look at a leaf for example,
that height would be 1 because the height of the left child is nil, is 0, and the
height of the nil right child is also 0. So the max of that is 0, 1 plus 0. We could also look at calculating the size
of a tree that is the number of nodes. Again, if we have a nil tree,
we have zero nodes. Otherwise, we have the number of
nodes in the left child plus 1 for ourselves plus the number of
nodes in the right child. So 1 plus the size of the left tree
plus the size of the right tree. In the next video, we're going to look
at different ways to traverse a tree.In this video, we're going to
continue talking about trees. And in particular, look at walking a tree,
or visiting the elements of a tree, or traversing the elements of a tree. So often we want to go through the nodes
of a tree in a particular order. We talked earlier, when we were looking
at the syntax tree of an expression, how we could evaluate the expression
by working our way up from the leaves. So that would be one way of walking
through a tree in a particular order so we could evaluate. Another example might be
printing the nodes of a tree. If we had a binary search tree, we might want to get the elements
of a tree in sorted order. There are two main ways
to traverse a tree. One, is depth-first. So there, we completely traverse one sub-tree
before we go on to a sibling sub-tree. Alternatively, in breadth-first search we
traverse all the nodes at one level before we go to the next level. So in that case, we would traverse
all of our siblings before we visited any of the children
of any of the siblings. We'll see some code examples of these. In depth-first search, so we're going to
look here at an in-order traversal. And that's really defined best for
a binary tree. This is InOrderTraversal is
what we might use to print all the nodes of a binary search
tree in alphabetical order. So, we're going to have a
recursive implementation, where if we have a nil tree,
we do nothing, otherwise, we traverse the left sub-tree, and then do
whatever we're going to do with the key, visit it, in this case,
we're going to print it. But often there's just some
operation you want to carry out, and then traverse the right sub-tree. So let's look at an example of this. We've got our binary search tree. And we're going to look at how these
nodes get printed out if we do an in-order traversal. So to begin with, we go to the Les node. And from there, since it's not nil, we're going to do an in-order traversal
of its left child, which is Cathy. Similarly now we're going to do
an in-order traversal of its left child, which is Alex. We do an in-order traversal of its left
child which is nil, so it does nothing. So we come back to Alex, and
then print out Alex, and then traverse its right sub-tree
which is nil and does nothing. We come back to Alex. And then we're finished with Alex and
we go back to Cathy. So, we have successfully
completed Cathy's left sub-tree. So we did an in-order traversal of that, so
now we're going to print Cathy, and then do an in-order traversal of its
right sub-tree, which is Frank. So we go to Frank, similarly
now we're going to print out Frank. We've finished with Frank and
go back to Cathy, and now we've completed Cathy totally,
so we go back to Les. We completed Les' left sub-tree, so
we're now going to print Les and then traverse Les' right sub-tree. So that is Sam,
traverse its left sub-tree which is Nancy. Print it out, go back to Sam,
we've completed Sam's left sub-tree, so we print Sam, and then go ahead and
do Sam's right sub-tree which is Violet, which will end up printing Tony,
Violet, and then Wendy. We're completed with Wendy. We go back to Violet. We completed her right sub-tree, so we go
back to Sam, completed his right sub-tree, go back to Les, completed his
right sub-tree, and we're done. So we see we get the elements
out in sorted order. And again, we do the left child. And then the node and
then the right child. And by our definition of
a binary search tree, that then gives them to us in order
because we know all the elements in the left child are in fact less than or
equal to the node itself. The next depth-first
traversal is a pre-order traversal. Now the in-order traversal really is
only defined for a binary tree because we talk about doing the left child and
then the node and then the right child. And so it's not clear if you
had let's say three children, where it is you'd actually
put the node itself. So you might do the first child and
then print the node, and then second and third child. Or first child and then second child and
print the node, and then third child. It's kind of undefined then,
so not well-defined. However, these next two, the pre-order and
post-order traversal are well defined. Not just for binary trees, but for general, arbitrary number
of children trees. So here the pre-order traversal says, we're going to go ahead
first if it's nil we return. We print the key first, that is, we visit
the node itself and then its children. So we're going to, in this case,
go ahead and go to the Les tree and then print out its
key and then go to its children. So we're going to first go to its
left child which is Cathy, and for Cathy, we then print Cathy, and then go to its left child which is Alex,
print Alex, we go back to Cathy. And we finished its left child, so then
we go do its right child, which is Frank. We finished Frank. We finished Cathy. We go back up to Les. We've already printed Les. We've already visited or
traversed Les' left child. Now we can traverse Les' right child,
so it'll be Sam, which we'll print out. And then we'll go to Nancy, which we'll
print out, we'll go back up to Sam and then to Violet, and we will print Violet,
and then print Violet's children, which will be Tony and
Wendy and then return back. A post-order traversal is like
a pre-order traversal expect instead of printing the node itself first, which is a
pre, we print it last, which is the post. So all we've really done is move
where this print statement is. And here then,
what's the last of these notes that's going to be printed?
Well it's actually going to be Les, because we're not going to be able
to print Les until we've finished completely dealing with Les' left sub-tree
and right sub-tree. So we'll visit Les, and
then visit Cathy, and then Alex, and then we'll actually print out Alex. Once we're done with Alex, we'll go
back up to Cathy and down to Frank, and then print out Frank, and
then once we're done with both Alex and Frank we can then print Cathy. We go back up to Les, and we now need to go deal with
Les' right child which is Sam. In order to deal with Sam we go to Nancy,
print Nancy, go back up to Sam and down to Violet, and deal with the Violet
tree, which will print out Tony, and then Wendy, and then Violet. And on our way back up, then, when we get
up to Sam, we have finished its children, so we can print out Sam. When we get up to Les, we've finished
its children, so we can print out Les. One thing to note about
the recursive traversal is we do have sort of under the covers,
a stack that's being used. Because in a recursive call, every time
we make a call back to a procedure, we are invoking another
frame on the stack. So we are saving implicitly our
information of where we are on the stack. Breadth-first, we're going to actually
use a queue instead of a stack. So in the breadth-first, we are going to
call it level traversal here, we're going to go ahead and
instantiate a queue, and on the queue first
put the root of the tree. So we put that in the queue and
then while the queue is not empty, we're going to dequeue, so pull a node
off, deal with that by printing it and then if it's got a left child, enqueue the left child, if it's got
a right child, enqueue the right child. And so this will have
the effect of going through and processing the elements in level order. We see the example here, and
we're going to show the queue. So here let's say we're just before
the while loop, the queue contains Les. And we're going to now dequeue Les from
the queue, output it by printing it, and then enqueue Les' children
which are Cathy and Sam. Now, we visit those in order, so first we're going to dequeue Cathy, print
it out and then enqueue its children. Remember when we're enqueuing
we go at the end of the line, so Alex and Frank go after Sam. So now we're going to dequeue Sam,
print it, and then enqueue its children Nancy and
Violet. So we can see what we've done then is,
we first printed Les, that's level one and then we printed the
elements of level two, which are Cathy and Sam, and now we're going to go on
to the elements at level three. So notice,
all the elements in level three, Alex, Frank, Nancy, and
Violet are in the queue already. And they're all going to be processed
before any of the level four nodes are processed.
So even though they'll be pushed in the queue, since the level three nodes got there first
that they're all going to be processed before we process the level four ones. So here, we dequeue Alex,
print it out, and we're done. Dequeue Frank, print it out,
we're done with Frank. Dequeue Nancy, print it out,
we're done with Nancy. And Violet, we print it out, but
then also enqueue Tony and Wendy, and then dequeue those and print them out. So this is a breadth-first search,
with an explicit queue, you can do depth-first searches
rather than recursively, iteratively, but you will need
an additional data structure which is a stack to keep track of
the work still to be done. So in summary, trees are used for lots
of different things in computer science. We've seen that trees have a key and normally have children, although there
are alternative representations of trees. The tree walks that are normally
done are traversals, are DFS: depth-first search,
and BFS: breadth-first search. There are different types of
depth-first search traversals, pre-order, in-order, and post-order. When you work with a tree,
it's common to use  recursive algorithms, although note that we didn't for the
breadth-first search where we needed to go through the elements of the tree
in kind of a non-recursive order. And finally, in computer science,
trees grow down.So in this lecture, we're going to talk about dynamic
arrays and amortized analysis. In this video we're going to
talk about dynamic arrays. So the problem with static arrays is,
well, they're static. Once you declare them,
they don't change size, and you have to determine
that size at compile time. So one solution is what are called
dynamically-allocated arrays. There you can actually allocate the array, determining the size of
that array at runtime. So that gets allocated
from dynamic memory. So that's an advantage. The problem is, what if you don't know the maximum size
at the time you're allocating the array? A simple example,
you're reading a bunch of numbers. You need to put them in an array. But you don't know how
many numbers there'll be. You just know there'll be some mark at the
end that says we're done with the numbers. So, how big do you make it? Do you make it 1,000 big? But then what if there are 2,000 elements? Make it 10,000 big? But what if there are 20,000 elements? So, a solution to this. There's a saying that says all
problems in computer science can be solved by another level of indirection. And that's the idea here. We use a level of indirection. Rather than directly storing
a reference to the either static or dynamically allocated array, we're going to store a pointer to
our dynamically allocated array. And that allows us then
to update that pointer. So if we start adding more and
more elements, when we add too many, we can go ahead and allocate a new array,
copy over the old elements, get rid of the old array, and
then update our pointer to that new array. So these are called dynamic arrays or
sometimes they're called resizable arrays. And this is distinct from
dynamically allocated arrays. Where we allocate an array, but once it's
allocated it doesn't change size. So a dynamic array is
an abstract data type, and basically you want it to
look kind of like an array. So it has the following operations,
at a minimum. It has a Get operation,
that takes an index and returns you the element at that index, and a Set operation, that sets an element at
a particular index to a particular value. Both of those operations
have to be constant time. Because that kind of what
it means to be an array, is that we have random access with
constant time to the elements. We can PushBack so that adds a new element
to the array at the end of the array. We can remove an element
at a particular index. And that'll shuffle down
all the succeeding ones. And finally, we can find out how
many elements are in the array. How do we implement this? Well, we're going to store arr,
which is our dynamically-allocated array. We're going to store capacity, which is the size of that
dynamically-allocated array, how large it is. And then size is the number of elements
that we're currently using in the array. Let's look at an example. So let's say our dynamically
allocated array has a capacity of 2. But we're not using any elements
in it yet, so it's of size 0. And arr then points to that
dynamically allocated array. If we do a PushBack of a,
that's going to go ahead and put a into the array and update the size. We now push b, it's going to put b
into the array and update the size. Notice now the size is equal to
the capacity which means this dynamically allocated array is full. So if we get asked to do another PushBack, we've got to go allocate a new
dynamically-allocated array. We're going to make that larger,
in this case it's of size 4. And then we copy over each of the elements
from the old array to the new array. Once we've copied them over, we can go
ahead and update our array pointer to point to this new dynamically allocated
array, and then dispose of the old array. At this point now we finally have
our new dynamically allocated array, that has room to push another element,
so we push in c. We push in d, if there is room
we put it in, update the size. And now if we try and push another element,
again we have a problem, we're too big. We can allocate a new array. In this case,
we're going to make it of size 8. We'll talk about how you determine
that size somewhat later. And then copy over a, b, c, and
d, update the array pointer, de-allocate the old array, and
now we have room we can push in e. So that's how dynamic arrays work. Let's look at some of the implementations
of the particular API methods. Get is fairly simple. So we just check and see, we're going to
assume for the sake of argument, that we are doing 0-based indexing here. So if we want to Get(i), we first
check and make sure, is i in a range? That is, is it non-negative, and is it within the range
from 0 to size i minus 1? Because if it's less than 0 or
it's greater or equal to size, it's out of range, that will be an error. If we're in range then
we just return index i from the dynamically allocated array. Set is very similar. Check to make sure out index is in bounds,
and then if it is, update index i of the array to val. PushBack is a little more complicated. So, let's actually skip the if
statement for now and just say, let's say that there is empty
space in our dynamic array. In that case, we just set array at
size to val and then increment size. If, however, we're full,
we're not going to do that yet, if size is equal to capacity,
then we go ahead and allocate a new array. We're going to make it twice the capacity,
and then we go through a for loop, copying over every one of the elements
from the existing array to the new array. We free up the old array and
then set array to the new one. At that point then,
we've got space and we go ahead and set the size element and
then increment size. Remove's fairly simple. Check that our index is in bounds and
then go ahead through a loop, basically copying over successive
elements and then decrementing the size. Size is simple, will just return size. There are common implementations for
these dynamic arrays and C++'s vector class is
an example of a dynamic array. And there, notice it uses
C++ operator overloading, so you can use the standard array
syntax of left brackets, to either read from or
write to an element. Java has an ArrayList. Python has the list. And there is no static arrays in Python. All of them are dynamic. What's the runtime? We saw Get and Set are O(1),
as they should be. PushBack is O(n). Although we're going to see
that's only the worst case. And most of the time actually,
when you call PushBack, it's not having to do the expensive operation, that
is, the size is not equal to capacity. For now, though,
we're just going to say that it's O(n). We'll look at a more detailed
analysis when we get into aggregate analysis in our next video. Removing is O(n), because we've
gotta move all those elements. Size is O(1). So in summary, unlike static arrays,
dynamic arrays are dynamic. That is, they can be resized. Appending a new element to a dynamic
array is often constant time, but it can take O(n). We're going to look at a more
nuanced analysis in the next video. And some space is wasted. In our case, if we're resizing by a factor
of two, at most half the space is wasted. If we were making our new
array three times as big, then we can waste two-thirds of our space. If we're only making it 1.5 as big,
then we would waste less space. It's worth noting dynamic array can also
be resized smaller, that's possible too. It's worth thinking about what if
we resized our array to a smaller dynamic array as soon as we got
under one-half utilization? And it turns out we can come up
with a sequence of operations that gets to be quite expensive. In the next video, we're going to
talk about amortized analysis. And in particular, we're going to look at
one method called the aggregate method.So we'll discuss now what
Amortized Analysis is and look at a particular method for
doing such analysis. Sometimes, we're looking at an individual
worst case and that may be too severe. In particular we may want to
know the total worst case for a sequence of operations and it may
be some of those operations are cheap, while only certain of them are expensive. So if we look at the worst
case operation for any one and multiply that by the total,
it may be overstating the total cost. As an example, for a dynamic array,
we only resize every so often. Most of the time, we're doing a constant
time operation, just adding an element. It's only when we fully reach
the capacity, that we have to resize. So the question is, what's the total cost
if you have to insert a bunch of items? So here's the definition
of amortized cost. You have a sequence of n operations, the amortized cost is the cost of
those n operations divided by n. This is similar in spirit to let's say you
buy a car for, I don't know, $6,000. And you figure it's going to
last you five years. Now, you have two possibilities. One, you pay the $6,000 and then five years later you have
to pony up another $6,000. Another option would be to
put aside money every month. So five years is 60 months. So if you put away $100 a month,
once the five years is over, then when it's time to buy a new car for $6000,
you'll have $6000 in your bank account. And so there that amortized cost
(monthly cost) is $100 a month, whereas the worst case monthly
cost is actually 6,000, it's 0 for 59 months and then it's 6,000
after one month, so you can see that, that amortized cost gives you
a more balanced understanding. If you really want to know what's
the most I spend in every month, the answer yes is $6,000. But if you want to know sort of
an average what am I spending, $100 is a more reasonable number. So that's why we do this
amortized analysis, to get a more nuanced picture of
what it looks like for a succession of operations. So let's look at the aggregate
method of doing amortized analysis. And the aggregate method really says,
let's look at the definition of what an amortized cost is, and
use that to directly calculate. So we're going to look at
an example of dynamic array and we're going to do n calls to PushBack. So we're going to start with an empty
array and n times call PushBack. And then we'll find out what the amortized
cost is of a single call to PushBack. We know the worst case time is O(n). Let's define c sub i as
the cost of the i'th insertion. So we're interested in c1 to cn. So ci is clearly 1. because we have got to actual, and what we're going to count for
a second here is writing into the array. So the cost is 1 because we have to write
in this i'th element that we're adding. Regardless of whether or
not we need to resize. If we need to resize, the first
question is when do we need to resize? We need to resize if our
capacity is used up. That is if the size is equal to capacity. Well when does that happen? That happens if the previous
insertion filled it up. That is made it a full power of 2, because in our case we're
always doubling the size. So that says on the i'th insertion we're going to have to resize
if the i'th- 1 filled it up. That is the i- 1 is a power of 2. And if we don't have to resize, there's
no additional cost, it's just zero. So the total amortized cost is really the sum of the n actual costs divided by n. So that's a summation from
i = 1 to n of c sub i. And again c sub i is the cost
of that i'th insertion. While that's equal to n,
because every c sub i has a cost of 1, so we sum that n times, that's n plus then
the summation from what's this, this looks a little complicated so j = 1 to the floor
of log base 2 of n- 1 of 2 to the j. That just really says the power of twos. All the way up to n- 1. So to give an example,
if n is 100, the power of 2s are going to be 1, 2,
4, 8, 16, 32, and 64. And it's the summation of all of those. Well that summation is just order n. Right.
We basically take powers of 2 up to but not including n. And that is going to be no more than 2n. So we've got n plus
something no more than 2n, that's clearly O(n) divided by n,
and that's just O(1). So what we've determined then
is that we have a amortized cost for each insertion of order 1. Our worst case cost is still order n, so if we want to know how long it's going to
take in the worst case for any particular insertion is O(n),
but the amortized cost is O(1). In the next video, we're going to look at an alternative
way to do this amortized analysis.In this video, we're going to talk about
a second way to do Amortized Analysis, what we call the Banker's Method. The idea here is that we're going to
charge extra for each cheap operation. So it's sort of like we're taking
the example where we looked at saving money for a car. We're going to actually take that $100 and
put it in the bank. And then we save those charges somewhere, in the case of the bank
we put it in the bank. In our case we're going to conceptually
save it in our data structure. We're not actually changing our code,
this is strictly an analysis. But we're conceptually thinking
about putting our saved extra cost as sort of tokens
in our data structure that later on we'll be able to use to
pay for the expensive operations. To make more sense as we see an example. So it's kind of like an amortizing loan or this case I talked about where we're
saving $100 a month towards a $6000 car, because we know our current
car is going to run out. Let's look at this same example
where we have a dynamic array and n calls to PushBack starting
with an empty array. The idea is we're going to charge 3 for
every insertion. So every PushBack,
we're going to charge 3. One is the raw cost for actually moving in this new item into the array,
and the other two are going to be saved. So if we need to do a resize in order
to pay for moving the elements, we're going to use tokens we've already
saved in order to pay for the moving. And then, we're going to place 1 token,
once we've actually added our item. 1 token on the item we added and
then 1 token on an item prior to this in the array. It'll be easier when we look
at a particular example. Let's look at an example
we have an empty array. And we're going to start with size 0,
capacity 0. We PushBack(a), what happens? Well we have to allocate our array
of size one, point to it, and then we put a into the array. And now we're going to put
a little token on a and this token is what we use to
pay later on to moving a. In this particular example for the very first element there's no
other element to put a token on. So we're just going to waste that other,
that third token. We push in b. There's no space for b so we've got to
allocate a larger array and then move a. How are we going to pay for that moving a? Well with the token
the token that's already on it. So we prepaid this moving a. When we actually initially
put a into the array, we put a token on it that would pay for
moving it into a new array. So that's how we pay for moving a and then we update the array, delete the old
one, and now we actually put b in. So we put b in at the cost of one,
we still have two more tokens to pay. So we're going to put one on b and
we're going to put one capacity over two that is one element earlier, so
we're going to put one on a. So we've spent three now. One for real and two as deferred payment that we're going
to use later in the form of these tokens. Remember these tokens are not actually
stored in the data structure. There's nothing actually in the array. This is just something we're using for mental accounting in
order to do our analysis. When we push in c,
we're going to allocate a new array. We copy over a and we pay for
that with our pre-paid token. We copy over b, paying for
that with our pre-paid token. And now we push in c. That's one,
the second payment we have to make is, we put a token on c and
we then we put token on a. Four divided by two, that is the capacity
divided by two, or two elements prior. We push in d,
we don't have to do any resizing, finally. Okay, so we just put in d and
that's the cost of one. Second, put a token on d. Third, put a token capacity over two or
two elements prior to that. So notice what we've got now is a full
array and everything has tokens on it which means when we need to resize,
we have prepaid for all of that movement. So we push in e, allocate a new array. And now we use those prepaid tokens
to pay for moving a, b, c, and d. Get rid of the old array,
and now push in e. And again, put a token on e,
and a token on a. So, what we've got here then is O(1)
amortized cost for each PushBack. And in particular,
we have a cost of three, right? So we have clearly seen. So lets look back at how we did this. For this dynamic array we decided we
had to charge three, and other data structures with other operations we
not did have to charge a different amount. We have to figure out
what will be sufficient, in our case three was sufficient, and
we decided that we would go ahead and store these tokens on
the elements that needed to be moved. So it's a very physical way to keep track
of the saved work that we have done, or the prepaid work that we have done. So we charge 3, 1 is 
the raw cost of insertion. If we need to resize, we've arranged
things such that whenever the array gets full, we've actually, in order for
the array to have been full, we had to have done enough PushBacks such
that every element got a token on it. All the new ones that we added since
the previous resize, plus every time we added one of those new ones,
we prepaid for a prior element as well. So, we pay our one insertion, we pay
one for the element we're adding now and we pay one for
sort of a buddy element earlier. In the next video we're going to look at
a third way of doing Amortized Analysis, which is the Physicist's Method.Now, let's talk about the final
way to do amortized analysis, which is the physicist's method. The idea of the physicist's method
is to define a potential function, which is a function that takes
a state of a data structure and maps it to an integer
which is its potential. This is similar in spirit to what you
may have learned in high school physics, the idea of potential energy. For instance, if you have a ball and
you take it up to the top of a hill, you've increased its potential energy. If you then let the ball roll down the
hill, its potential energy decreases and gets converted into kinetic
energy which increases. We do the same sort of thing for our data structure, storing in it
the potential to do future work. Couple of rules about
the potential function. First, phi of h sub 0. So, phi is the potential function. h sub 0 is time 0 of the data structure h,
so that means the initial state of the data structure, and
that has to have a potential of 0. Second rule is that
potential is never negative. So, at any point in time, phi of h
sub t is greater than or equal to 0. So, once we've defined
the potential function, we can then say what amortized cost is. The amortized cost of an operation
t is c sub t, the true cost, plus the change in potential, between, before doing the operation and
after doing the operation. So, before doing the operation,
we have phi(h sub t-1) after we have phi(h sub t), so it's c sub t plus
phi(h sub t)- phi(h sub t-1). What we need to do is choose
a function phi, such that, if the actual cost is small,
then we want the potential to increase. So that we're saving up some potential for
doing later work. And if c sub t is large,
then we want the potential to decrease. In a way to sort of pay for that work. So, the cost of in operations
is the sum of the true costs which is a summation from
i goes from one to n of c sub i. And, what we want to do is relate
the sum of the true costs to the sum of the amortized costs. So, the sum of the amortized costs is
the summation from i equals 1 to n of the definition of the amortized cost. Which is (c sub i + phi(hsub i) - 
phi(h sub i-1)). Or, we could just rewrite that. So, removing the summation is c sub 1
+ phi of (h sub 1)- phi of (h sub 0), + c sub 2 + phi of (h sub 2)-
phi of (h sub 1) and so on. What's important to note is that we have
a phi of h sub 1 in the first line and then a minus phi of h sub 1 in the second
line, so those two cancel out. Similarly, we have a phi of h
sub 2 in the second line, and we have a phi of h sub 3 when we look
at the amortized cost at time three. And, that goes on and
on until at time n-1, we would have a phi of h sub n-1 positive and
a negative phi of h sub n-1 negative. So, if all these cancellations and
all we're left with is the very first term phi of h sub 0,
negative phi of h sub 0, and the very last term in the last
line which is phi of h sub n. So, this really just equals phi of h sub n
minus phi of h sub 0 because all the other phis cancel, plus the summation
from i equals 1 to n of c sub i, that is the true costs. Since phi of h sub n is non negative and
phi of h sub 0 is 0, this value is greater than or equal to
just the summation of the true costs. What that means then is we've
come up with a lower bound on the sum of the amortized
costs which is the sum of the true costs. So therefore, if we want to look at a cost
of a entire sequence of operations, we know it's at least
the sum of the true costs. So, let's look at applying this
physicist's method to the dynamic array. So, we're going to look
at n calls to PushBack. Phi of h, so, at any given time the data structure's going to be two
times the size minus the capacity. So, as the size increases,
the potential's going to be increasing for a given fixed capacity. Phi of x sub here, so we want to make sure that our phi
function satisfies our requirements. So, first phi of 0 is 2 x 0- 0, assuming we have an initial array
of size 0, and that's just 0. Also, phi of h sub i
is 2 x size - capacity. We know that size is at
least capacity over 2, so therefore, 2 x size - capacity
is greater than 0. Now, let's look at our amortized cost. So, we're going to assume we
don't have to do a resize and let's look at the amortized cost. So, we add a particular element i and
the amortized cost is the cost of insertion plus
phi(h sub i) - phi(h sub i-1). So, the cost of insertion is just going to
be 1 because we're adding an element and we don't have to do any
moving of elements. Phi of h sub i is 2 x size
of i - the capacity of i, and phi of h sub i- 1 is 2 x
size i- 1 - capacity i- 1. Well, what do we know? Since we're not resizing and
the capacities don't change. So, the capacities cancel themselves out. And so, we are left with 2
times the difference in sizes. What's the difference in size? Difference in size is just 1,
because we added one element, so this is 1 + 2 x 1 or 3. It's no accident that this 3 is the same value that we saw when we
used the banker's method. And then, let's look at the cost
when we have to do a resize. So, we're going to define
here k is size sub i-1, which is the same thing
as capacity sub i-1. Why is it the same? because we're about to do a resize. So, that means that after
the previous operation, we must have made the dynamic array full. And then,
phi(h sub i-1) is just 2 times the old size minus the old capacity,
and that's just 2 x k - k, or k. Phi(h sub i) is 2 times
the size of i - capacity of i, and that's 2(k + 1), because
the size sub i is one more than the size of i-1, minus 2k. Why 2k? Because we double the capacity each time. So, that's just equal to 2. So, the amortized cost of adding the
element is c sub i + phi(h sub i) - phi(h sub i - 1), which is just size of i,
because that's the number of elements we have to, we have to move size of i-1
elements and then add the one new element, so, that's size of i. So, we have (sizei)+2-k,
which is just (k+1)+2-k, which is 3. So, what we have seen now is
that the amortized cost using the physicist's method
of adding elements is 3.All right, in this support video,
we're gonna look at Java's List Interface, the ArrayList class, as well as how to use
generics, which are these different types. You've already seen Mia working with
lists and ArrayLists, and using generics. And you're gonna be using these
classes and generics in your project. But if you're feeling like you need
a little bit more review or overview of what these classes, and what generics are,
then watch the support video. So by the end of this video,
you'll be able to comfortably work with ArrayLists and Lists in Java,
which are both built in to Java. And you'll also be able to create these
objects to work with Java generics. So let's go back to one of the examples
that Mia used in her video. She created this list countries
that stored an ArrayList object. So for now in this example, I just want you to ignore this piece
right here inside the angle brackets. That's the generics part of this, and
we're gonna talk about that later. But for now what I want you to focus
on is the types of the variable as well as the object that gets created. So the variable that gets created
countries is of type list. And you can see over here that the object
that gets created is type ArrayList. So you might be kind of
worried at this point. And you might be thinking what's going on? These two types are not the same. Is that even allowed? And the answer is that yes,
this is absolutely allowed in Java. And we're gonna explain
briefly what's going on here. So a List, as Mia mentioned in her video
is what's called an abstract data type. And what it i, is a Java interface which we're going
to get into more in the next module. But what that means is it implements,
it specifies, some behavior that this
object has to have, but doesn't talk about exactly how that
behavior is going to be implemented. So you can use that as the type
of a particular variable. On the other hand, over here when we actually create
the object itself, that's an actual class. So the ArrayList is an actual
class that's built into Java. And it implements all of the behavior
that's specified by the list interface. This class can be instantiated. And it's perfectly okay to have an
interface as the type of the variable, and the actual class as the type of
the thing that you instantiate. That's done a lot. And again, don't worry too
much about the details here. We're going to get more into this in the
next module as well as in future courses in this specialization. For now let's just ask the question. Okay we've got anArrayList object,
let's think about what can it do? Well if I wanna know what a class
that's built into java can do, where should I look? How about the Javadocs? That's your go-to place to figure out
what can my classes built into Java actually do? Here's the URL for
the Javadocs for version 8. If you're using a different
version of Java, you'll need to change that 8 to a 7 or
whatever version you happen to be using. Or my favorite is I just google for
javadoc documentation and then whatever version of
java I happen to be using. And this link will come right up. So if I click on this link, it's going
to take me to this page here and that's the overview for
the Java documentation. And now the question is,
where the heck is ArrayList? How are you gonna find it. Well there's a couple ways. You can either look down here. This is this full list of all the classes
and libraries that are built into Java. So you will find ArrayList in this
big long list, but it's pretty long. So a faster way to get yourself to
ArrayList is to know what package it's in. So the packages are listed up here. And if you know that ArrayList is in
java.util, which I'm telling you now, so know you know, you can look in this package list
to find the java.util package. Then you can click on java.util
in that package list. And that will narrow down the list
of classes to only the classes and interfaces that are in java.util. So then you can go down here to
the list of classes that are shown. Click on the ArrayList class and up will
come the documentation for the ArrayList. Okay, so now you've got the documentation
page for the ArrayList. And it's pretty long, and it talks about
a lot of things the ArrayList can do. And I just wanna call out a few different
methods that you're going to find useful. Okay, now let's talk about setting an
element in an array and in an ArrayLists. To set an element in an array, you just
use that square bracket notation and you put it on the left hand side
of your assignment statement. So, in this case, we're taking a feature
that stored in the variable f and were putting it into the 0 index
position in our array, countryArray. To do this in an ArrayList,
we're going to use the method called set. Set takes two arguments,
a index location, in this case, 0, and
the thing we're trying to put there. And again, countries is our ArrayList and we can call the set method on our
countries variable, passing in 0 for index position, and
f the feature we want to store there. Now again, our ArrayList in both cases,
our Array and our ArrayList, have to have at least one
element in them, space for one element. Otherwise we're gonna get another
index out of bounds exception. Again if you wanna see the Java
documentation, it looks like that. Finally, let's talk about how to get
the length, or the size, of an ArrayList. So with an array, you know that you
can just call that length field. So I say countryArray.length, that will give me back the number
of elements in my array. But for an ArrayList it's
just a little bit different. Instead of calling a length field,
we're going to call the size method. So down here, we can see a method called size which
is just like length in an array. It returns the number of elements
that are in the ArrayList. Now notice one important thing,
that size is actually a method. So we have to have these parentheses
even though they're empty. It takes no parameters. It just returns the size
of the ArrayLists. So, we can see that arrays and
ArrayLists are very very similar, just some minor differences in
how you interact with them. But arrays, it turns out,
are actually a bit more powerful. Sorry, ArrayLists are more powerful than
arrays, because arrays, as you know, once you create them and
set their size, they're fixed. But ArrayLists can expand to
incorporate more elements. So there are these two
methods of ArrayLists add, they take different numbers of parameters. And what they do is they actually
append the new element onto the end of the list increasing the size
of the ArrayList as necessary. So that's kind of cool. Of course, it doesn't force you to specify
how big you want your array beforehand. Java will automatically
resize the ArrayList for you. So that's one of the reasons
we often use ArrayList instead of arrays cuz they provide for
this extra flexibility. Okay. So now let's go back to
this issue of generics. So now we're gonna talk about the code
that's inside those angle brackets. Notice that we're creating
here two different lists. There's countries and countryMarkers. And they're both lists, but the difference
is that countries stores features. And markers store, oh sorry,
the country markers, store markers. So this is what this generics
capability allows us to specify. What we put in the angle
brackets is the type of object that we want Java to store inside
the container that we're creating. So in this case we're creating a list. The first list is allowed
to store features. And the second list is
allowed to store Markers. Now, when we go to create these objects
that are referenced by these variables, we again have to say what kind of
thing goes into the container object. So we can see over here
on the left hand side, we've said the first list
is going to store Features. The second list is going to store Markers. And so on the right hand side
the first ArrayList stores Features. The second ArrayList stores markers,
and these types have to match. Now what this allows us to do if we
add a bit more code, let's say we've got some code here that will put some
elements into both of these lists,. The cool part about generics is now
when we get elements out of the list, when we get elements out of country. Say we get the element at position zero. We know that countries stores Features. So we can get back
a Feature type reference. On the other hand, countryMarkers,
we declared was going to store Markers. So when we get an element
back from countryMarkers, it's going to be of Marker type. So it's the same exact method, this
getmethod, is gonna return a different type depending on what we
declared the container to store. So that's really cool. We don't have to use any casts,
or anything like that. It just happens automatically for us. And bringing this back around to the Java
docs, if you look at that getMethod in the Javadocs, you'll see that
it lists the return type as E. And what that means is that it's
this generic type that's gonna take on whatever type you declare
the container to hold. So, generics are really useful,
ArrayLists and lists, really useful. You're gonna work with them in
the project which is coming up next.In this module we're gonna begin looking
at inheritance and polymorphism in Java. Inheritance and polymorphism
are incredibly power features to any other oriented programing language but
unlike lobes and conditionals you don't usually need to use inheritance
and polymorphism for your code to work. When you first started programming, you probably could have put a lot of your
code in main and gotten away with it. But as your code grew,
you started using methods, and then later started using classes. Likewise, as the complexity
of your project grows and you start working on large software
design projects, you start having to use inheritance and polymorphism to be able
to handle the complexity of the project. You've already worked with inheritance and
polymorphism to some extent by having used the keyword
extends in your previous modules. What we're going to do here is
start working in more detail with inheritance and polymorphism. The goal here for this single video is to
look at the value of inheritance and self. We're gonna do this by
posing a potential problem. Imagine you're a software
engineer at a university, and you've been working for
some time on a Person class. You've actually tested the code, it's much
longer than the code that you see here, and you're very happy with it. But your software design
team comes back to you and says, we really can't just
have one class anymore. This needs to start behaving
differently for students or faculty. So you think about how
are you gonna solve this, and there's a couple potential solutions. Neither of these are gonna be good
solutions, so I'm not gonna dive into too much detail with them, but let's talk
through what you might try to do. The first option is really to say, well, I'm gonna keep all this
in the Person class. And I'm just gonna have it behave
differently if you're a student or faculty member. And I'm gonna do this by having
a boolean which just says whether or not you're a student. True if you're a student,
false if you're faculty. I'm gonna add a constructor that
handles it this way as well. And then in each of my methods,
I can just do if student, do the code for the student,
else do the code for the faculty. And at this point this doesn't
seem like that bad of an idea. What's going to happen is your software
design team is going to come back to you later and say, you know we can't
have all students behave the same, undergrads and graduate students
are going to behave differently. They have different needs,
graduate students have thesis advisors, things like that. Then they come back to you and say well we need you to behave differently
if you're a full time student or you're a part time student. So what you'll do is you'll add now
boolean flags to say whether or not this is a graduate student or not and a boolean flag to keep track of
whether you're full time or not. And now your methods gonna start looking
something like if you're a student and you're a grad student and you're full time
and if this sounds really ugly, it is. In fact, this kind of ugly code
has a specific name for it. You may have heard of it before. It's called spaghetti code. Now I like spaghetti, but
I don't like spaghetti code. Spaghetti code is code that you're gonna
write, you're gonna realize how bad it is, you're gonna throw it away,
and you're gonna start over. So this solution we're not happy with. Let me propose another potential solution. Let's just take my Person class and
copy paste it into two files and we name one to be Student and
the other to be Faculty. And then within the Student class
I'm gonna change all the code to match the behavior of a student, and
within the Faculty I'm gonna change all the code to match the behavior
of a faculty member. At this point this seems like
a pretty reasonable solution. This will actually work for
a little while. But it's not going to work indefinitely. Take a few seconds to think
where it might go wrong. All right. If your answer had anything to do with
either consistency or the ability to store all the objects in one data structure,
you're on the right track. So let's talk through it in both of those. What's gonna happen is your design team's
gonna come back to you and they're gonna say at some point, you know having
a single string name isn't sufficient. We really need you to break this
out as first name and last name. And this isn't a major change,
so you go into your code, you start changing all the instances
of name to now work with first name and last name and
you fix all of the Student class. And then you're gonna realize, wait,
I had name in the Faculty class, too. And you can't just copy-paste the code
that you just changed in Student into Faculty. You're gonna have to
rewrite all the Faculty, do all the changes you just made
in Student to the Faculty code. It's gonna be tedious and
it's unnecessary. But more important,
what if you make a mistake? What if you miss a change in
Faculty that you made in Student? This is gonna be really
hard to keep consistent. The other problem with this is that there is probably some code
that has an array of persons right now. What's gonna happen if I now break this
into two classes, only students and only faculty. Well I can't keep that single
array of persons anymore. I'm gonna have to keep two arrays,
one for students and one for faculty. I know there's no clean way to keep
a single data structure for all persons. And you may say,
well why is that important? Well, what if I just wanted to sort by
the time that the person came on campus? That would be really hard to do. I could sort the students potentially,
I could sort the faculty, but how do I merge those? It's gonna get ugly pretty quick. So, neither of these answers
are things that we're happy with. What do we want then? Essentially, we figured out the goals
by looking at these two examples. The goals here are 1, to keep all
of our common code in one class. It'd be great if we could do that. We also would like it, so
if we have different behaviors, I split that different behavior
into different classes. And lastly,
I wanna be able to keep all these objects in one single data structure. Now these are somewhat lofty goals, but the good news is,
they all come to us with inheritance. We're gonna dive into the details about
how to do this in the next video.In the last video we began to
see the power of inheritance and polymorphism in Java. In this video,
we're gonna start diving into the details. How do we make this work? The goal here is to use the keyword
extends, and recognize what that does. We're gonna talk about the relationship
between superclass and subclasses and what those terms mean. And we're gonna use UML Diagrams to
design our first class hierarchy. We left off at the last video
saying we want three key features. We wanna be able to keep
common code in one class, we wanna be able to split out different
code between different classes, and we want to be able to keep all
the objects in one single data structure. In this video, we're gonna show how we can
do one and two by designing our hierarchy. Item three will be in the next video. Where we left off was talking about
three different classes Person class, a Student class and a Faculty class. And in a sense we want to have all
the common code in the person class and we want to have our diverging code in
the student and the faculty classes. To do this it would be great if we
could have all the power of person and all the features of person get
inherited into the student class. So let's focus on that one first. Now it might seem really powerful to
inherit all the features of another class, and it is, but you can do it
with just one keyword, extends. So if you say extends person,
that means inherits from. It means the student class is
gonna inherit from person, many of the features of the person class. So when you've used this
before in previous modules, this was a really powerful thing to do,
to say, extends. So what you get when you, before I say
that, let's talk about some terminology. The Person class here is a base class,
sometimes called a super class and sometimes called a Parent class. The Student class here is a derived
class or a sub class or a child class. Now what features do you actually inherit? You inherit public instance variables,
and that makes sense. You inherit the public methods. So the student's gonna get all
the public methods of person. You're also gonna inherit the private
instance variables, in a sense. So we'll talk about that
in a little more detail. So since you're inheriting the private
instance variables do you really still need to have that instance
variable with student called name? No, in fact it's a really
bad idea to do that. That would be called a hidden variable or
shadow variable and it's hard to discern which variable,
which name variable you're talking about. The one in student or the one in person. So you actually wouldn't have that, cuz you inherited it
automatically from person. But there is one catch, because it's
a private instance variable you can only access it through public methods so
you'll have to use the getters and setters to access name. Now that we have an idea of
how we can use inheritance, let's start talking about how we can
design an inheritance hierarchy. Now if you're working on
a whiteboard with a design team, you're not gonna wanna
write out the whole class. You're gonna wanna have a very
small representation of a class. The way to do this is
known as a UML Diagram. I have an example of this on the right. Now there's a number of different
variants of how you can display this. This is just one example. I have the person class name at the top. I have the instance variable string name,
and then I have the method below that. So you have again, class name,
instance variables and methods, all within this
concise representation. Let's add in the student class
which is a extending person. May add that in,
you're gonna realize that's blank, and that's because there are no incidence
variables and no methods within student. Now that keyword extends along
with person is gonna say, student inherits from person. And to do that,
all you have to do is draw that line. So, that line just says,
student is inheriting from person. Let's start talking about
our full hierarchy. Let's bring back in Faculty into to this. So, we have our Person class and
I two derived classes, my Student class and my Faculty class. This alone is already an inheritance
hierarchy, or a class hierarchy. What I want you to do is pause. Take a few seconds to think about
what would belong in a Student class that wouldn't belong in
a Faculty class and vice versa. Again take a few seconds,
pause the video and we'll come back. All right,
there are a number of good answers here. Let's just talk through
a couple that I thought of. So students get grades in their classes. In the American education system,
we use this thing called a GPA, which is essentially just an average
of all the grades that you've gotten. Students would have these,
Faculty would not. So in the Student class,
I'd have an instance variable named GPA, and then I'd have an access or
method called getGPA. What belongs in a Faculty class that
wouldn't belong in a Student class? Well, maybe an office number or
office phone, but also a salary. So, Faculty get paid,
students generally do not. So I might have an instance
variable called double salary, and I'm gonna have a method called
getSalary to get access to this. We've already started designing
our inheritance hierarchy. We have the code that's common
up in the person class. We have the code that's divergent
in the Student class and Faculty class is separately. This answers items 1 and
2 from our desire list. But we haven't answered three yet and
that's coming up in the next video.In the last video we began using
the keyword extends to unlock the power of Inheritance in JAVA. We also designed our
first class hierarchy and we're gonna continue
with that in this video. The goal here is to understand
what the term is a means. And how it defines a relationship
necessarily between classes. In the last video, we saw how
designing our class hierarchy and using the keyboard extends gives us
the first two features on this list. It allows us to keep all the common code
in one class, allows us to split out the different behavior between separate
classes, but what we didn't answer was how can we keep all the objects
in one single data structure. And to figure this out,
let's play an old fashioned matching game. What I have here on
the left is a Reference and on the right I have an Object. What we're gonna do is
essentially play a matching game. We're gonna try and figure out, can you
have this Reference point to this Object. Let's start off with
Person p = new Person ();. You've done this a whole bunch,
is this legal, absolutely. The reason this is legal is
because A Person is-a Person. Somewhat reflective we
kind of recognize that. We'll use this term though,
again as we go forward. Likewise, is a Student a Student,
absolutely. A Student is-a Student. Where this gets interesting is, can you have a Reference,
Person point to a Student Object? What I want you to do is think about this,
just for a few seconds. Do you think this should be allowed? I hope you said yes. This should be allowed. Now, this is new. You've likely always ran code where
the Reference was the exact same thing as the Object, but
you're actually allowed to do this. And the reason you're allowed to do
this is because a Student is a Person. All the capabilities that a Person has,
a Student has to have, because it's derived from Person. This is fantastic,
because what this allows us to do now, is keep one single array of Student and
Faculty objects. So this code where I create a array
of Persons, a references to Persons. And then I can fill it with
references to a Person object, to a Student object, and
to a Faculty object. This code compiles and
will work just fine. So we can now keep,
whether your person is Student or Faculty, all in one data structure. This is fantastic. And we haven't finished
our matching game yet. Can you have a Student Reference
point to a Person Object? The answer here is, no. Why? Well, not all the features of a Student
are necessarily within a Person. And you could think about it kind
of loosely as an analogy of, if you walked up to a random person on the
street and asked them what their GPA is. Well, that's probably not a very polite
question to ask in the first place, but if you were to ask it,
most people would say, I'm not a student. What are you asking me? This is why you can't do this. Now, why I brought up this example is because we get to polymorphism
in just a few videos. References and
Objects are gonna become front and center. We're gonna talk about what decisions are
made of compile time, based on reference type and what decisions are made at
run time based on object actual type. But before we can get there, we have a few more details to work out
with inheritance in the next videos.All right, you've learned
a little bit about inheritance. And you've played that matching game
with Leo where you learned what kinds of references can refer to
what kinds of objects. It turns out that is a really,
really tricky idea to get. So, we've got a concept challenge for you that's gonna exercise your
ability to make those matches. Don't worry if this is
a little bit tricky. It takes a while to get it. So work through it, you know the drill. Work through it on your own, answer
the end video quiz, discuss with others, watch our learner videos, and
then watch our explanation. Here's your challenge. You've got three classes. There's a Person class,
it has a name, member variable. And it has a getName, method. There's a Student class
which extends person. It has an ID member variable that's
an integer, and it has a getID method, it returns an integer, and there's
a Faculty class which also extends Person. It also has an ID variable, but
this time it's a string, and it has a getID method
that returns a string. We have five statements over there on
the right that create new objects and assign references to refer
to those new objects. All of those statements compile and
run just fine. Your question is going to be to answer
questions about which of an additional series of statements work, and which cause
errors at either compile time or run time. >> Okay, my name is Linda. >> My name's Mustafa. >> My name is Jason. So how did you guys answer question one. >> I seem to think that question
one didn't have any issues. S is a student, and they're trying to get the name from the student, and-
>> Well I thought there was a problem with that
because when I look at the class of Student I realize there is
no method called getName. >> That's true, but
Student extends from Person. >> So it will inherit all
the parent class methods. >> Yeah, it's a public method. >> Oh so, it will inherit
the Persons getName method. >> Right, yeah. >> Oh okay, I see. What about the second p = s? >> For the second one,
I also thought it was fine. >> That's fine? >> Cuz Person p is a new Person. And if you change the reference
of p to become the object created from Student s equals new Student,
then every Student is a Person. >> Okay, so that's the part that I missed. I was thinking it would be a problem cuz
Student and Person are not the same type, so I wasn't sure if you
could cast it that way. >> Oh, right.
>> So too much p instead of referencing to Person,
I was referencing to Students. >> Mm-hm.
>> Okay. >> If that makes sense? >> Yeah, okay.
>> Now look at the next line of- >> I don't think that would work because Person doesn't have a getID method-
>> Right. >> So
where would it be looking to get that? >> I thought that during compile time
error since p is still a Person, it'll go into the Person class and then
look at, oh, where's the getID method? >> But didn't we just updated a Person
class with pointing to a Student class? >> Mm-hm.
>> The compiler doesn't know that. The compiler still sees it as a Person
object because it was originally set up that way. >> It's only at run time that the compiler
will see that p is actually a Student. >> Oh, okay.
Even that I believe we have to cast it I guess. >> Right.
>> Mm-hm. >> How about the third line of code,
faculty equals Person? >> Person? >> Well person isn't
necessarily a Faculty member. So like he was saying that
if you go around and ask a random person on the street, they might
not have the information for faculty. So I'm not sure if you can cast
the faculty as a broad term person. >> Right, not every person is faculty. >> Right.
>> Yeah that makes sense. And then the last one,
o equals a Student, or object class equals Student class. >> I think we've previously learned that
every object inherits from the object class, right? >> Yeah. >> Oh, I see. >> So s is a Student. >> Okay, I like,
every class would inherit object meaning. There's implicit extent. >> Yeah, yeah exactly. >> Perfect. >> All right let's step through these
lines one at a time to figure out which ones work and which ones cause errors. This first line here,
it's pretty straightforward. It creates a new variable
of type String called n, and it's gonna set it
equal to s.getName(). Well first we need to
figure out what is s. Well s is a Student reference,
it's a reference to a Student. And it actually does refer
to a Student object. And you can see that right here,
when we created that Student object and assigned the reference s to point to. So now we can look in the Student class
and see if there's a getName method. We look here, no getName method, but that doesn't concern us too much,
because Student extends Person. So now we can go up in person and
look at those getName method there. And sure enough, there is. It returns a string. So this will run just fine, again,
because this getName method is public. So everything is good. This line will work just fine. The next line says that the reference
p should be set to refer to the same location as
the reference s refers to. Now s refers to a Student object. What we're saying is that now p
should refer to a Student object, and we have to figure out if that's okay. Is it okay for a Person reference to refer
to an object that's actually a student? So you ask the question
are all students people? Is a student always a person? And I hope the answer is always yes. So that should be just fine. That line works as well. Next line here says that int
m gets the value of p.getID. Now, we have to think about
things a little more carefully. So what we're asking, assuming that
this line has already completely, and p now refers to a Student object, we
wanna know is it okay to call p a getID. There is a getID method
inside the student class, but the problem is that p
is a Person reference. So the compiler doesn't know that p
actually refers to a Student object. The compiler is gonna complain
about this statement here. It's gonna say it's a piece of reference
to a Person, I don't know about this getID method, there's no getID method in Person
class, and so I'm gonna cause an error. We can fix this with a cast. So if we wanted to fix this problem,
we would just insert a cast here. We could cast p, so
instead of just p, we'd say Student, and then p right there, and then .getID. Because we know that object
is actually a Student. So that's fine to do, but again,
be a little careful with your cast because your compiler will trust
you no matter what you say. We can do this in this case
cuz we know that's the term. All right, so the next statement there, so
going back actually to the last statement, this statement right here. This statement right there
does not work as written, but it will work if we add that cast. Let's consider the next line,
where it says f gets the value of q. So what is f? F is a Faculty reference. It's a reference to some
sort of Faculty object. And what is q? Well, q is a reference to a Person. So now we need to figure out if a Faculty
reference can point to a person object. And again we will ask the question,
are all people faculty? And the answer to that
question is of course no. So we can't set a Faculty reference
equal to a Person object. That will cause an error. And there's nothing that we
can do to make that work. If we try to cast q to a faculty,
compiler might accept it, but at run time we're going to get
what is called a class cast exception, because it's illegal to cast
a Person object to a Faculty type. That line will not work. What about this next
line where we say o = s. So o is an Object type reference,
and s is a Student object, up here. Well, that should work, right? Because everything in Java is an Object. The Object text references
are allowed to point to any kind of Object that they want. So that one's pretty straightforward. That works. So now we're done. And to summarize what we found was
this first line here was just fine. The next line here was also just fine,
because all students are people. The next line is not okay. But we could make it okay with a cast. The next line was there not okay and there is nothing we could
do to make that line work. And finally this last
line here was just fine.Welcome back. At this point we've been
talking about what's inherited? We've used the terms private and
public and those visibility modifiers impact what
gets inherited from one class to another. What we're gonna do now is spend
a little more time looking at the different visibility modifiers and
how they impact us. Particularly in relation to inheritance. By the end of this video, you should be
able to use the appropriate visibility modifiers when you're writing your class. Up to this point,
your comfortable probably with public which is less restrictive and
private which is more restrictive. So public gives access to any other class. Where as private gives
access only the same class. Well there's two, well at this point you
likely have learned this rule of thumb. Make all your instance variables private,
you should make your public interface, you're public methods public. You can also have private methods,
those are your helper methods. This rule of thumb is
actually still gonna apply. Even if we talk about the other
visibility modifiers, it's important to know how they apply. The other visibility modifiers
are protected and package. So protected gives you access to any,
so within the same class, anything within the same package can access it,
and any sub class can access it. Package, also sometimes called default, you have access from the same class, and
you have access from the same package. The only difference really
between package and protected is that package
loses access by any sub class. So, sub-classes that are still in the same
package, you still have access to. The sub-classes outside your
package you're gonna lose. To really understand this
it helps to see an example. What I have here is a sample class. And that sample class has a pubic
variable, a protected variable, a package variable or
default variable and then a private room. Let's add a whole bunch of other classes. Some within the same package,
the dotted line denotes package, and then some are sub classes. We have sub-class one in the same package, we have sub-class two,
which is outside of the package. We have Other1, which just happens to be another
class in the same package as Sample. Then we have Other2,
which is a class not in the same package, it has no relationship in terms
of inheritance with Sample. If you have the public visibility, so w. W is accessible from anyone else. And notice that I'm just saying public w, I'm not putting the public int,
you can fill in the value there yourself. So, public anyone can access. Protected, you only essentially
take away access to Other2. Things within the same package, as well
as sub-classes, can access this variable. Now, What I'm concerned about here, is why
does Other1 have access to my variable X? Is it because it's in the same package? Does that really make sense, is that who
we want to have access to our variables? In general,
this is not a very good idea, and this is why we don't
recommend using protected. If we look at package access,
what you see is that we've now taken away access to the sub-class 2, and
what we had from protected. Which you'll notice that
Other1 still has access to y. And why is some other class in
the same package happen to have access to my variable? It doesn't make much sense and this is why
we don't recommend package access, either. Lastly, we have private access,
which you're comfortable with, just means within this class
you can access this variable. Now that we've walked through
the different levels of access, you see that public is the least restrictive and
private is the most restrictive. But we still are gonna apply
the same rule of thumb. Always use public or private, there's only rare cases that you'll
ever wanna use protected or packaged.As we continue on in
this module on Inheritance, what we're gonna do next is look
at object construction in Java. Now, you've already reconstructed before,
so you might say, well, wait a second why
are we revisiting this? Well, the reason we're revisiting this
is because now we know inheritance, we now know some more details about
how objects actually get constructed. So the goals of this video
is to recognize that all objects actually are derived
from the object class. And you may already know that but
we're gonna dive into some details about how that actually works
over the course of the next few videos. And we're also gonna look at
how Java actually constructs or initializes its objects
really from the inside out. We'll talk about what we mean
by that in just a moment. We're gonna keep working with this
in hierarchy that we've been working with before, where we have a person class,
a super class, and the student and the faculty classes is drive classes. And we're gonna focus in on
essentially one line of code, Student s = new Student();. We know the new statement,
new is actually an operator. That operator means allocates space. And a second piece to this
is once given that space, pass a reference to that space to
the constructor for initialization. In fact constructors really should
be called Initializers, and you'll see in other programming languages
that they're actually called init. So really what the student
constructor does is just initialize the variables associated with student. And the way that's gonna do this is
essentially from the inside out. So you can go all the way up the
hierarchy, all the way up to object and then you can come back down. As you come back down you're gonna
initialize all those variables. And what we're gonna do is step
through this step by step to understand how this works. So first thing you do after you've new, you've created the space object you've
passed that space through the constructor. The student constructor then, it's very first line of code is gonna
send you to the superclass constructor. In this case, Person. The very first line of code of
the person constructor is gonna immediately send you to it's indirect
superclass or in this case, Object. Now, the object constructor can initialize
the variables associated with object, essentially filling in
that part of the object. Once it's done, it returns back to Person. Person now can initialize it's variables. And then it's gonna
return back to Student. And Student now is gonna initialize
the variables associated with Student. And through this process we've essentially
initialized all these variables, went all the way up to object,
and all the way back down. And that's what we mean by
initializing inside out. What you may be thinking at this point is,
Wait. I don't remember ever extending
from the object class. And you may not have done so
explicitly, but it still happens. And we'll talk about how that
happens in the next video.